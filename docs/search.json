[
  {
    "objectID": "wyklad2S.html",
    "href": "wyklad2S.html",
    "title": "Wykład 2",
    "section": "",
    "text": "Oczekiwania vs Rzeczywistość\n\nKiedy podjąć decyzję biznesową ?\n\n\n\n\nBatch = Duże, historyczne zbiory\nStream = Strumień danych, on line, przesyłane w trybie ciągłym\n\n\n\n\n\nBatch = minuty, godziny, dni (patrz Hurtownie danych)\nStream = Real-time/near-real-time\n\n\n\n\n\nBatch = możliwe i stosowane bardzo czesto\nStream = ,,niemożliwe’’\n\n\n\n\n\nExtract, Transform, Load is a basic pattern for data processing, commonly known in data warehousing. It’s all about extracting data from a source, transforming the data (business rules) and at the end writing/loading everything to a target (Hadoop, Relational Database, Data Warehouse etc.)\n\n\n\nGdy mówimy o skali (nie o języku Scala), najczęściej przychodzi nam na myśl przeglądarka Google. Przeszukuje ona ogromne zbiory danychz dużą prędkością. Sama nazwa Goolge wskasuje na skalę (colowo przyjęto błędną nazwę w zapisie googol co oznacza 1 i 100 zer).\n\nSprawdź czy do końca zajęć uda Ci się zapisać liczbę googol na kartce.\n\nPowinno być dla Ciebie jasne, że żadne tradycyjne systemy, np relacyjne systemy baz danych, ani programowanie imperatywne nie są w stanie obłużyć przeszukiwania takiej ilości danych. Problemy te doprowadziły do budowy rozproszonych systemów plików Google File System, MapReduce (paradygmat programowania równoległego), czy Bigtable (skalowalna pamięć masowa ustrukturyzowanych danych znajdujących się na GFS).\n\n\nZnajdź prosty algorytm map reduce w dowolnym języku programowania i uruchom go.\n\n\nJak poprawić ?"
  },
  {
    "objectID": "wyklad2S.html#batch-vs-stream-processing",
    "href": "wyklad2S.html#batch-vs-stream-processing",
    "title": "Wykład 2",
    "section": "",
    "text": "Oczekiwania vs Rzeczywistość\n\nKiedy podjąć decyzję biznesową ?\n\n\n\n\nBatch = Duże, historyczne zbiory\nStream = Strumień danych, on line, przesyłane w trybie ciągłym\n\n\n\n\n\nBatch = minuty, godziny, dni (patrz Hurtownie danych)\nStream = Real-time/near-real-time\n\n\n\n\n\nBatch = możliwe i stosowane bardzo czesto\nStream = ,,niemożliwe’’\n\n\n\n\n\nExtract, Transform, Load is a basic pattern for data processing, commonly known in data warehousing. It’s all about extracting data from a source, transforming the data (business rules) and at the end writing/loading everything to a target (Hadoop, Relational Database, Data Warehouse etc.)\n\n\n\nGdy mówimy o skali (nie o języku Scala), najczęściej przychodzi nam na myśl przeglądarka Google. Przeszukuje ona ogromne zbiory danychz dużą prędkością. Sama nazwa Goolge wskasuje na skalę (colowo przyjęto błędną nazwę w zapisie googol co oznacza 1 i 100 zer).\n\nSprawdź czy do końca zajęć uda Ci się zapisać liczbę googol na kartce.\n\nPowinno być dla Ciebie jasne, że żadne tradycyjne systemy, np relacyjne systemy baz danych, ani programowanie imperatywne nie są w stanie obłużyć przeszukiwania takiej ilości danych. Problemy te doprowadziły do budowy rozproszonych systemów plików Google File System, MapReduce (paradygmat programowania równoległego), czy Bigtable (skalowalna pamięć masowa ustrukturyzowanych danych znajdujących się na GFS).\n\n\nZnajdź prosty algorytm map reduce w dowolnym języku programowania i uruchom go.\n\n\nJak poprawić ?"
  },
  {
    "objectID": "wyklad2S.html#strumienie-danych",
    "href": "wyklad2S.html#strumienie-danych",
    "title": "Wykład 2",
    "section": "Strumienie danych",
    "text": "Strumienie danych\nStrumieniowanie możesz kojarzyć z serwisów przesyłających video w trybie online. Gdy oglądasz swój ulubiony serial (tak jak teraz na zajęciach) serwis odpowiadający za strumieniowanie w nieprzerwany sposób przesyła do ciebie kolejne “porcje” video. Identycznie koncepcja ta realizowana jest w przypadku danych strumieniowych. Format przesyłanych porcji nie musi być plikiem video, wszystko zależy od celu realizowanego biznesowo. Np. ciągły pomiar z różnego rodzaju czujników w farbykach, elektrowniach itp. Warto odnotować, że masz do czynienia z ciągłym strumieniem danych, które przetwarzać musisz w czasie rzeczywistym. Nie możesz czekać do zatrzymania linii produkcyjnych w celu wykonania analizy, wszystkie pojawiające się problemy chcesz rejestrować natychmiast i jak najszybciej na nie reagować.\n\nAnaliza strumieni danych to ciągłe przetwarzanie i analiza dużych zbiorów danych w ruchu.\n\nPorównuj to do wsakazanych powyżej elementów Big Data. Przetwarzanie Batchowe jest przeciwieństwem do przetwarzania strumieniowego. Najpierw zbierasz duże ilości danych a potem realizujesz analizy. Możesz oczywiście zawsze pobrać video w całości zanim je obejrzysz, ale czy miałoby to sens? Istnieją przypadki gdy takie podejście nie stanowi problemu, ale już tu widzisz, że przetwarzanie strumieniowe może przynieść dla biznesu dodatkowe wartości dodane, których trudno oczekiwać przy wsadowym przetwarzaniu.\nciekawe informacje\n\nŹródła danych przesyłanych strumieniowo obejmują:\n\nczujniki sprzętu,\nstrumienie kliknięć,\nśledzenie lokalizacji\ninterackcja z użytkownikiem: co robią użytkownicy Twojej witryny?\nkanały mediów społecznościowych,\nnotowania giełdowe,\naktywność w aplikacjach\ninne.\n\nFirmy wykorzystują analitykę strumieniową do odkrywania i interpretowania wzorców, tworzenia wizualizacji, przekazywania spostrzeżeń i alertów oraz uruchamiania procesów w czasie rzeczywistym lub zbliżonym do rzeczywistego.\n\n\nPrzykładowe biznesowe zastosowania\n\nDane z sensorów IoT i detekcja anomalii\nStock Trading (problemy regresyjne) - czas reagowania na zmiany i czas zakupy i sprzedaży akcji.\nClickstream for websites (problem klasyfikacji) - śledzenie i analiza gości na stronie serwisu internetowego - personalizacja strony i treści.\n\n8 najlepszych przykładów analizy w czasie rzeczywistym\nBiznesowe zastosowania\n\nPrzedsiębiorstwo to organizacja, która generuje i odpowiada na ciągły strumień zdarzeń.\n\nAnalityka strumieniowa (ang. stream analytics) nazywana jest również przetwarzaniem strumieniowym zdarzeń (ang. event stream processing) - przetwarzanie dużej ilości danych już na etapie ich generowania.\nNiezależnie od zastosowanej technologi wszystkie dane powstają jako ciągły strumień zdarzeń (działania użytkowników na stronie www, logi systemowe, pomiary z sensorów)."
  },
  {
    "objectID": "wyklad2S.html#czas-w-analizie-danych-w-czasie-rzeczywistym",
    "href": "wyklad2S.html#czas-w-analizie-danych-w-czasie-rzeczywistym",
    "title": "Wykład 2",
    "section": "Czas w analizie danych w czasie rzeczywistym",
    "text": "Czas w analizie danych w czasie rzeczywistym\nW przypadku przetwarzania wsadowego przetwarzamy dane historyczne i czas uruchomienia procesu przetwarzania nie ma nic wspólnego z czasem występowania analizowanych zdarzeń.\nDla danych strumieniowych mamy dwie koncepcje czasu:\n\nczas zdarzenia (event time) - czas w którym zdarzenie się wydarzyło.\nczas przetwarzania (processing time) - czas w którym system przetwarza zdarzenie.\n\nW przypadku idealnej sytuacji:\n\nW rzeczywistości przetwarzanie danych zawsze odbywa się z pewnym opóźnieniem, co reprezentowane jest przez punkty pojawiające się poniżej funkcji dla sytuacji idealnej (poniżej diagonalnej).\n\nW aplikacjach przetwarzania strumieniowego istotne okazują się różnice miedzy czasem powstania zdarzenia i jego procesowania. Do najczęstszych przyczyn opóźnienia wyszczególnia się przesyłanie danych przez sieć czy brak komunikacji między urządzeniem a siecią. Prostym przykładem jest tu przejazd samochodem przez tunel i śledzenie położenia przez aplikację GPS.\nMożesz oczywiście zliczać ilość takich pominiętych zdarzeń i uruchomić alarm w sytuacji gdy takich odrzutów będzie za dużo. Drugim (chyba częściej) wykorzystywanym sposobem jest zastosowanie korekty z wykorzystaniem tzw. watermarkingu.\nProces przetwarzania zdarzeń w czasie rzeczywistym można przedstawić w postaci funkcji schodkowej, reprezentowanej na rysunku: \nJak można zauważyć nie wszystkie zdarzenia wnoszą wkład do analizy i przetwarzania. Realizację procesu przetwarzania wraz z uwzględnieniem dodatkowego czasu na pojawienie się zdarzeń (watermark) można przedstawić jako proces obejmujący wszystkie zdarzenia powyżej przerywanej linii. Dodatkowy czas pozwolił na przetworzenie dodatkowych zdarzeń, natomiast nadal mogą zdarzyć się punkty, które nie będą brane pod uwagę.  \nPrzedstawione na wykresach sytuacje jawnie wskazują dlaczego pojęcie czasu jest istotnym czynnikiem i wymaga ścisłego określenia już na poziomie definiowania potrzeb biznesowych. Przypisywanie znaczników czasu do danych (zdarzeń) to trudne zadanie."
  },
  {
    "objectID": "wyklad2S.html#okna-czasowe",
    "href": "wyklad2S.html#okna-czasowe",
    "title": "Wykład 2",
    "section": "okna czasowe",
    "text": "okna czasowe\nOkno rozłączne (ang. tumbling window) czyli okno o stałej długości. Jego cechą charakterystyczną jest to, iż każde zdarzenie należy tylko do jednego okna.  \nOkno przesuwne (ang. sliding window) obejmuje wszystkie zdarzenia następujące w określonej długości między sobą.  \nOkno skokowe (ang. hopping window) tak jak okno rozłączne ma stałą długość, ale pozwala się w nim na zachodzenie jednych okien na inne. Stosowane zazwyczaj do wygładzenia danych.  \nKomunikacja sieciowa, relacyjne bazy danych, rozwiązania chmurowe i big data znacząco zmieniły sposób budowania systemów informatycznych i wykonywnia na niach pracy.\nPorównaj to jak “narzędzia” do realizacji przekazu (gazeta, radio, telewizja, internet, komunikatory, media społecznościowe) zmieniły interakcje międzyludzkie i struktury społeczne.\n\nKażde nowe informatyczne medium zmieniło stosunek ludzi do informatyki.\n\nKoncepcja mikrousługi (mikroserwisu) jest bardzo popularnym sposobem budowania systemów informatycznych jak i koncepcją przy tworzeniu oprogramowania czy realizacji firmy w duchu Data-Driven. Koncepcja ta pozwala zachować wydajność (rób jedną rzecz ale dobrze), elastyczność i jasną postać całej struktury.\nChociaż istnieją inne sposoby architektury projektów oprogramowania, „mikroserwisy” są często używane nie bez powodu. Idea mikroserwisów tkwi w nazwie: oprogramowanie jest reprezentowane jako wiele małych usług, które działają indywidualnie. Patrząc na ogólną architekturę, każda mikrousługa znajduje się w małej czarnej skrzynce z jasno zdefiniowanymi wejściami i wyjściami. Możesz porównać tego typu zachowanie do “czystej funkcji” w programowaniu funkcyjnym.\nW celu umożliwienia komunikacji różnych mikroserwisów często wybieranym rozwiązaniem jest wykorzystanie Application Programming Interfaces API .\n\nKomunikacja przez API\nCentralnym elementem architektury mikrousług jest wykorzystanie interfejsów API. API to część, która pozwala na połączenie dwóch mikroserwisów. Interfejsy API są bardzo podobne do stron internetowych. Podobnie jak strona internetowa, serwer wysyła do Ciebie kod reprezentujący stronę internetową. Twoja przeglądarka internetowa interpretuje ten kod i wyświetla stronę internetową.\nWeźmy przypadek biznesowy z modelem ML jako usługą. Załóżmy, że pracujesz dla firmy sprzedającej mieszkania w Bostonie. Chcesz zwiększać sprzedaż i oferować naszym klientom lepszą jakość usług dzięki nowej aplikacji mobilnej, z której może korzystać nawet 1 000 000 osób jednocześnie. Możemy to osiągnąć, udostępniając prognozę wartości domu, gdy użytkownik prosi o wycenę przez Internet.\n\nCzym jest serwowanie modelu ML\n\nSzkolenie dobrego modelu ML to TYLKO pierwsza część całego procesu: Musisz udostępnić swój model użytkownikom końcowym. Robisz to, zapewniając dostęp do modelu na swoim serwerze.\nAby udostępnić model potrzebujesz: modelu, interpretera, danych wsadowych.\nWażne metryki\n\n\nczas oczekiwania,\nkoszty,\nliczba zapytać w jednostce czasu\n\n\nUdostępnianie danych między dwoma lub więcej systemami zawsze było podstawowym wymogiem tworzenia oprogramowania – DevOps vs. MLOps.\n\nGdy wywołasz interfejs API, otrzyma on Twoje żądanie. Żądanie wyzwala kod do uruchomienia na serwerze i generuje odpowiedź odesłaną do Ciebie. Jeśli coś pójdzie nie tak, możesz nie otrzymać żadnej odpowiedzi lub otrzymać kod błędu jako kod stanu HTTP.\n\nKlient-Serwer: Klient (system A) przesyła żądanie przez HTTP do adresu URL hostowanego przez system B, który zwraca odpowiedź. Identycznie działa np przeglądarka internetowa. Żądanie jest kierowane do serwera WWW, który zwraca tekstową stronę HTML.\n\n\nBezstanowe: Żądanie klienta powinno zawierać wszystkie informacje niezbędne do udzielenia pełnej odpowiedzi.\n\nInterfejsy API można wywoływać za pomocą wielu różnych narzędzi. Czasami możesz nawet użyć przeglądarki internetowej. Narzędzia takie jak CURL wykonują zadanie w wierszu poleceń. Możesz używać narzędzi, takich jak Postman, do wywoływania interfejsów API za pomocą interfejsu użytkownika.\n\nCała komunikacja jest objęta ustalonymi zasadami i praktykami, które są nazywane protokołem HTTP.\n\n\n\nZapytanie - Request\n\nAdres URL (np. http://mydomain:8000/getapi?&val1=43&val2=3) zawiera: - domenę, - port, - dodatkowe ścieżki, - zapytanie\nMetody HTTP: - GET, - POST\nNagłówki HTTP zawierają: - informacje o autoryzacji, - cookies metadata Cała informacja zawarta jest w Content-Type: application/json, text … Accept: application/json, Authorization: Basic abase64string, Tokens\nCiało zapytania\n\nNajczęściej wybieranym formatem dla wymiany informacji między serwisami jest format JavaScript Object Notation (JSON). Przypomina on pythonowy obiekt słownika - “klucz”: “wartość”.\n{\n\"RAD\": 1,\n\"PTRATIO\": 15.3, \"INDUS\": 2.31, \"B\": 396.9,\n\"ZN\": 18,\n\"DIS\": 4.09, \"CRIM\": 0.00632, \"RM\": 6.575, \"AGE\": 65.2, \"CHAS\": 0, \"NOX\": 0.538, \"TAX\": 296, \"LSTAT\": 4.98\n}\n\n\nOdpowiedź - Response\n\nTreść odpowiedzi przekazywana jest razem z nagłówkiem oraz statusem:\n\n200 OK\nContent-Encoding: gzip\nContent-Type: text/html; charset=utf-8\nDate: Mon, 18 Jul 2016 16:06:00 GMT Server: Apache\nPath=/;\n\nnp.: “Content-Type” =&gt; ”application/json; charset=utf-8”, ”Server” =&gt; ”Genie/Julia/1.8.5”\nTreść (ciało) odpowiedzi:\n\n{\":input\":{\"RAD\":1,\"PTRATIO\":15.3,\"INDUS\":2.31,.....}}, {\":prediction\":[29.919737211857683]}\n\nHTTP status code: • 200 OK - prawidłowe wykonanie zapytania, • 40X Access Denied • 50X Internal server error\n\n\nWyszukaj informacje czym jest REST API.\n\n\nWiedza:\n\nZna możliwości i obszary zastosowania procesowania danych w czasie rzeczywistym\nRozumie potrzeby biznesowe podejmowania decyzji w bardzo krótkim czasie\n\n\n\nUmiejętności:\n\nRozumie ograniczenia wynikające z czasu przetwarzania przez urządzenia oraz systemy informatyczne\n\n\n\nKompetencje:\n\nUtrwala umiejętność samodzielnego uzupełniania wiedzy teoretycznej jak i praktycznej w zakresie programowania, modelowania, nowych technologii informatycznych z wykorzystaniem analizy w czasie rzeczywistym.\nFormułuje problem analityczny wraz z jego informatycznym rozwiązaniem"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Informacje ogólne",
    "section": "",
    "text": "Kod: 222890-D\nSemestr letni 2024, SGH Szkoła Główna Handlowa w Warszawie\nPodstawowe informacje znajdziesz w sylabusie.\nCiekawe książki i strony internetowe zamieszczone zostały w zakładce książki. Jeśli chciał(a)byś coś dodać prześlij informację przez MS teams.",
    "crumbs": [
      "222890-D",
      "Informacje ogólne"
    ]
  },
  {
    "objectID": "index.html#analiza-danych-w-czasie-rzeczywistym",
    "href": "index.html#analiza-danych-w-czasie-rzeczywistym",
    "title": "Informacje ogólne",
    "section": "",
    "text": "Kod: 222890-D\nSemestr letni 2024, SGH Szkoła Główna Handlowa w Warszawie\nPodstawowe informacje znajdziesz w sylabusie.\nCiekawe książki i strony internetowe zamieszczone zostały w zakładce książki. Jeśli chciał(a)byś coś dodać prześlij informację przez MS teams.",
    "crumbs": [
      "222890-D",
      "Informacje ogólne"
    ]
  },
  {
    "objectID": "index.html#kalendarz",
    "href": "index.html#kalendarz",
    "title": "Informacje ogólne",
    "section": "Kalendarz",
    "text": "Kalendarz\n\nWykład\nWykład jest realizowany w trybie stacjonarnym. Jest on NIEOBOWIĄZKOWY i odbywa się w Auli II bud G\n\n\n26-02-2024 (poniedziałek) 09:50-11:30 - Wykład 1\n\nTematy zrealizowane na wykładzie:\n\n\nDane ustrukturyzowane i nieustrukturyzowane\nProcesy generowania danych\nBig Data\n\n\n\n04-03-2024 (poniedziałek) 09:50-11:30 - Wykład 2\n\nTematy zrealizowane:\n\n\nModele przetwarzania danych OLTP, OLAP\nSzybkość podejmowania decyzji\nDefinicje eventów, strumieni danych\nczas w strumieniach danych\n\n\n\n11-03-2024 (poniedziałek) 09:50-11:30 - Wykład 3\n\nTematy zrealizowane:\n\n18-03-2024 (poniedziałek) 09:50-11:30 - Wykład 4\n\n\n25-03-2024 (poniedziałek) 09:50-11:30 - Wykład 5\n\n\n\nTEST 20 pytań! - 30 minut.\nPrzygotowanie środowiska pracy\n\nTest przeprowadzany jest za pośrednictwem MS Teams.\n\n\nLaboratoria\n\n\n08-04-2024 (poniedziałek) 08:00-13:20 - C2D 3 grupy\n\n\n09-04-2024 (wtorek) 09:50-17:00 - Sabinki 16 3 grupy\n\n\n\nWprowadzenie do środowiska Python - API FLask\n\n\n\n15-04-2024 (poniedziałek) 08:00-13:30 - C2D, 3 grupy\n\n\n16-04-2024 (wtorek) 09:50-17:00 - Sabinki 16, 3 grupy\n\n\n\nAPI Flask kontrola zapytań i odpowiedzi\nProducent Apache Kafka\n\n\n\n22-04-2024 (poniedziałek) 08:00-13:30 - C2D, 3 grupy\n\n\n23-04-2024 (wtorek) 09:50-17:00 - Sabinki 16, 3 grupy\n\n\n\nDane ustrukturyzowane i ich modelowanie\nZadania: czyszczenie danych tabelarycznych\n\n\n\n29-04-2024 (poniedziałek) 08:00-13:30 - C2D, 3 grupy\n\n\n30-04-2024 (wtorek) 09:50-17:00 - Sabinki 16, 3 grupy\n\n\n\nGodziny rektorskie\n\n\n06-05-2024 (poniedziałek) 08:00-13:30 - C2D, 3 grupy\n07-05-2024 (wtorek) 09:50-17:00 - Sabinki 16, 3 grupy\n13-05-2024 (poniedziałek) 08:00-13:30 - C2B, 3 grupy\n14-05-2024 (wtorek) 09:50-17:00 - Sabinki 16, 3 grupy\n20-05-2024 (poniedziałek) 08:00-13:30 - C2B, 3 grupy\n21-05-2024 (wtorek) 09:50-17:00 - Sabinki 16, 3 grupy\n27-05-2024 (poniedziałek) 08:00-13:30 - C2B, 3 grupy\n28-05-2024 (wtorek) 09:50-17:00 - Sabinki 16, 3 grupy\n03-06-2024 (poniedziałek) 08:00-13:30 - C2B, 3 grupy\n04-06-2024 (wtorek) 11:40-17:00 - Sabinki 16, 3 grupy\n\n\n\n\nMiejsce\nWykłady 1-5: G-Aula II Laboratorium 1-9: C2D, Sabinki 16\n\n\nZaliczenie i Egzamin\nWykłady zakończone zostaną testem (ostatnie zajęcia). Pozytywna ocena z testu (powyżej 13 pkt) upoważnia do realizacji ćwiczeń.\nPo ćwiczeniach realizowane będą zadania domowe przekazywane za pośrednictwem platformy teams.\nZaliczenie wszystkich ćwiczeń i zadań upoważnia do realizacji projektu.\nProjekt powinien być realizowany w grupach max 5 osobowych.\nWymagania projektu:\n\nProjekt powinien przedstawiać BIZNESOWY PROBLEM, który można realizować wykorzystując informacje podawane w trybie online. (Nie oznacza to, że nie można korzystać z procesowania batchowego np w celu wygenerowania modelu).\nDane powinny być przesyłane do Apache Kafki i stamtąd poddawane dalszemu procesowaniu i analizie.\nJęzyk programowania jest dowolny - dotyczy każdego komponentu projektu.\nMożna wykorzystać narzędzia BI\nŹródłem danych może być tabela, sztucznie generowane dane, IoT itp.",
    "crumbs": [
      "222890-D",
      "Informacje ogólne"
    ]
  },
  {
    "objectID": "index.html#technologie",
    "href": "index.html#technologie",
    "title": "Informacje ogólne",
    "section": "Technologie",
    "text": "Technologie\nUczestnicząc w zajęciach musisz opanować i przynajmniej w podstawowym zakresie posługiwać się następującymi technologiami informatycznymi:\n\nGIT\nPython, Jupyter notebook, Jupyter lab, Colab\nDocker\nApache Spark, Apache Flink, Apache Kafka, Apache Beam\nDatabricks Community edition Web page.",
    "crumbs": [
      "222890-D",
      "Informacje ogólne"
    ]
  },
  {
    "objectID": "info.html",
    "href": "info.html",
    "title": "Narzędzia",
    "section": "",
    "text": "W terminalu (Windows CMD) wpisz\npython\nJeśli nie odnaleziono komendy uruchom polecenie:\npython3\nJeśli zadne z powyzszych poleceń nie działa, oznacza to, ze nie posiadasz interpretera python na swoim komputerze i musisz go doinstalować.\nSprawdź równiez polecenia\npython -m pip --version\npython -m pip3 --version\nPolecenia pip słuzą do instalacji pakietów.\nZwróć uwagę, aby Twoja wersja nie była niższa niż 3.X Aby wyjść z powłoki pythona użyj funkcji exit()\nPython 3.10.9 (main, Dec 15 2022, 17:11:09) [Clang 14.0.0 (clang-1400.0.29.202)] on darwin\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; exit()\nWarto zweryfikować równiez informację do którego środowiska pythona odnosi się poszczególna komenda.\n\n\nDo efektywnej pracy nad dowolnym projektem, zaleca się utworzenie dedykowanego środowiska wirtualnego z bibliotekami dostosowanymi do potrzeb konkretnego projektu. Takie podejście pozwala uniknąć problemów związanych z nadpisywaniem bibliotek.\npython3 -m venv venv\n# uruchom środowisko\nsource venv/bin/activate\n# . env/bin/activate\n\n(venv)$ \nW powyzszym przykładzie wykorzystaliśmy pakiet venv (python -m venv) do utworzenia nowego środowiska (katalogu) o nazwie venv.\nUruchomienie środowiska odbywa się z wykorzystaniem komendy source (lub .).\nPamiętaj, ze w przypadku systemu Windows środowisko uruchamia się przez\nvenv/Scripts/activate\nPosiadając nowe (puste) środowisko wykonaj następujące czynności: 1. Zainstaluj nowe wersje podstawowych pakietów\npip install --no-cache --upgrade pip setuptools\nSzybka instalacja podstawowych bibliotek i jupyter notebook.\n\npip install notebook numpy pandas matplotlib scipy\n\n# uruchom \njupyter notebook\nW przeglądarce internetowej wpisz: localhost:8888\nPo ponownym uruchomieniu przejdź do katalogu w którym utworzyłeś środowisko, następnie uruchom środowisko i jupyter.\nsource &lt;name of env&gt;/bin/activate\njupyter notebook\n\n\n\nKurs podstaw pythona Tomas Beuzen polecam.\nUtwórz konto na Kaggle, przejdź do zakładki Courses i przerób cały moduł Pythona. Zawiera on:\n\nwyrażenia i zmienne\nfunkcje\nwarunki i flow programu\nlisty\npętle\nstringi i słowniki\ndodawanie i używanie zewnętrznych bibliotek"
  },
  {
    "objectID": "info.html#python",
    "href": "info.html#python",
    "title": "Narzędzia",
    "section": "",
    "text": "W terminalu (Windows CMD) wpisz\npython\nJeśli nie odnaleziono komendy uruchom polecenie:\npython3\nJeśli zadne z powyzszych poleceń nie działa, oznacza to, ze nie posiadasz interpretera python na swoim komputerze i musisz go doinstalować.\nSprawdź równiez polecenia\npython -m pip --version\npython -m pip3 --version\nPolecenia pip słuzą do instalacji pakietów.\nZwróć uwagę, aby Twoja wersja nie była niższa niż 3.X Aby wyjść z powłoki pythona użyj funkcji exit()\nPython 3.10.9 (main, Dec 15 2022, 17:11:09) [Clang 14.0.0 (clang-1400.0.29.202)] on darwin\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; exit()\nWarto zweryfikować równiez informację do którego środowiska pythona odnosi się poszczególna komenda.\n\n\nDo efektywnej pracy nad dowolnym projektem, zaleca się utworzenie dedykowanego środowiska wirtualnego z bibliotekami dostosowanymi do potrzeb konkretnego projektu. Takie podejście pozwala uniknąć problemów związanych z nadpisywaniem bibliotek.\npython3 -m venv venv\n# uruchom środowisko\nsource venv/bin/activate\n# . env/bin/activate\n\n(venv)$ \nW powyzszym przykładzie wykorzystaliśmy pakiet venv (python -m venv) do utworzenia nowego środowiska (katalogu) o nazwie venv.\nUruchomienie środowiska odbywa się z wykorzystaniem komendy source (lub .).\nPamiętaj, ze w przypadku systemu Windows środowisko uruchamia się przez\nvenv/Scripts/activate\nPosiadając nowe (puste) środowisko wykonaj następujące czynności: 1. Zainstaluj nowe wersje podstawowych pakietów\npip install --no-cache --upgrade pip setuptools\nSzybka instalacja podstawowych bibliotek i jupyter notebook.\n\npip install notebook numpy pandas matplotlib scipy\n\n# uruchom \njupyter notebook\nW przeglądarce internetowej wpisz: localhost:8888\nPo ponownym uruchomieniu przejdź do katalogu w którym utworzyłeś środowisko, następnie uruchom środowisko i jupyter.\nsource &lt;name of env&gt;/bin/activate\njupyter notebook\n\n\n\nKurs podstaw pythona Tomas Beuzen polecam.\nUtwórz konto na Kaggle, przejdź do zakładki Courses i przerób cały moduł Pythona. Zawiera on:\n\nwyrażenia i zmienne\nfunkcje\nwarunki i flow programu\nlisty\npętle\nstringi i słowniki\ndodawanie i używanie zewnętrznych bibliotek"
  },
  {
    "objectID": "info.html#zacznij-korzystać-z-serwisu-github",
    "href": "info.html#zacznij-korzystać-z-serwisu-github",
    "title": "Narzędzia",
    "section": "Zacznij korzystać z serwisu GitHub",
    "text": "Zacznij korzystać z serwisu GitHub\n\n\n\nTekst na podstawie strony jak korzystać z serwisu github\nPracując nad projektem np. praca magisterska, (samodzielnie lub w zespole) często potrzebujesz sprawdzić jakie zmiany, kiedy i przez kogo zostały wprowadzone do projektu. W zadaniu tym świetnie sprawdza się system kontroli wersji czyli GIT.\nGit możesz pobrać i zainstalować jak zwykły program na dowolnym komputerze. Jednak najczęściej (małe projekty) korzysta się z serwisów z jakimś systemem git. Jednym z najbardziej rozpoznawanych jest GitHub dzięki któremu możesz korzystać z systemu git bez jego instalacji na swoim komputerze.\nW darmowej wersji serwisu GitHub swoje pliki możesz przechowywać w publicznych (dostęp mają wszyscy) repozytoriach.\nSkupimy się wyłącznie na darmowej wersji serwisu GitHub.\ngit --version\n\nStruktura GitHuba\nNa najwyższym poziomie znajdują się konta indywidualne (np http://github.com/sebkaz, bądź zakładane przez organizacje. Użytkownicy indywidualni mogą tworzyć repozytoria publiczne (public ) bądź prywatne (private).\nJeden plik nie powinien przekraczać 100 MB.\nRepo (skrót do repozytorium) tworzymy za pomocą Create a new repository. Każde repo powinno mieć swoją indywidualną nazwę.\n\n\nBranche\nGłówna (tworzona domyślnie) gałąź rapozytorium ma nazwę master.\n\n\nNajważniejsze polecnia do zapamiętania\n\nściąganie repozytorium z sieci\n\ngit clone https://adres_repo.git\n\nW przypadku githuba możesz pobrać repozytorium jako plik zip.\n\n\nTworzenie repozytorium dla lokalnego katalogu\n\n# tworzenie nowego katalogu\nmkdir datamining\n# przejście do katalogu\ncd datamining\n# inicjalizacja repozytorium w katalogu\ngit init\n# powinien pojawić się ukryty katalog .git\n# dodajmy plik\necho \"Info \" &gt;&gt; README.md\n\nPołącz lokalne repozytorium z kontem na githubie\n\ngit remote add origin https://github.com/&lt;twojGit&gt;/nazwa.git\n\nObsługa w 3 krokach\n\n# sprawdź zmiany jakie zostały dokonane\ngit status\n# 1. dodaj wszystkie zmiany\ngit add .\n# 2. zapisz bierzący stan wraz z informacją co zrobiłeś\ngit commit -m \" opis \"\n# 3. potem już zostaje tylko\ngit push origin master\nWarto obejrzeć Youtube course.\nCiekawe i proste wprowadzenie mozna znaleźć tutaj"
  },
  {
    "objectID": "info.html#zacznij-korzystać-z-dockera",
    "href": "info.html#zacznij-korzystać-z-dockera",
    "title": "Narzędzia",
    "section": "Zacznij korzystać z Dockera",
    "text": "Zacznij korzystać z Dockera\n\n\n\nW celu pobrania oprogramowania docker na swój system przejdź do strony.\nJeżli wszystko zainstalowało się prawidłowo wykonaj następujące polecenia:\n\nSprawdź zainstalowaną wersję\n\ndocker --version\n\nŚciągnij i uruchom obraz Hello World i\n\ndocker run hello-world\n\nPrzegląd ściągnietych obrazów:\n\ndocker image ls\n\ndocker images\n\nPrzegląd uruchomionych kontenerów:\n\ndocker ps \n\ndocker ps -all\n\nZatrzymanie uruchomionego kontenera:\n\ndocker stop &lt;CONTAINER ID&gt;\n\nUsunięcie kontenera\n\ndocker rm -f &lt;CONTAINER ID&gt;\nPolecam również krótkie intro"
  },
  {
    "objectID": "lab/cw1.html",
    "href": "lab/cw1.html",
    "title": "Środowisko produkcyjne z modelem ML",
    "section": "",
    "text": "Naszym zadaniem jest wystawić aplikację w pythonie realizującą zadania REST API. Na ządanie klienta serwer udzieli odpowiedzi na podstawie predykcji wygenerowanej z jakiegoś modelu.\nObraz ten zostanie skonterenryzowany z wykorzystaniem pliku Dockerfile dzięki czemu uruchomienie serwera stanie się mozliwe nie zaleznie od platformy.\nNasze zadanie zrealizujemy z wykorzystaniem biblioteki Flask w wersji 3.0.3.\nIstnieją inne biblioteki realizujące to zadanie. &gt; Sprawdź samodzielnie w domu czy potrafisz je uzyć, albo przynajmniej przeczytać kod.",
    "crumbs": [
      "222890-D",
      "Ćwiczenia",
      "Środowisko produkcyjne z modelem ML"
    ]
  },
  {
    "objectID": "lab/cw1.html#kod-minimalnej-aplikacji-flask",
    "href": "lab/cw1.html#kod-minimalnej-aplikacji-flask",
    "title": "Środowisko produkcyjne z modelem ML",
    "section": "Kod minimalnej aplikacji flask",
    "text": "Kod minimalnej aplikacji flask\nNaszą aplikację chcemy uruchomić lokalnie a potem w łatwy sposób przenieść i wykonać na dowolnym komputerze. Z tej przyczyny naturalnym rozwiązaniem jest zapis kodu do pliku z rozszerzeniem .py.\nW celu autozapisu kodu aplikacji do pliku app.py wykorzystamy magiczną komendę %%file plik.py.\n\n%%file app.py\nfrom flask import Flask\n\n# Create a flask\napp = Flask(__name__)\n\n# Create an API end point\n@app.route('/')\ndef say_hello():\n    return \"Hello World\"\n\nif __name__ == '__main__':\n    app.run() # domyślnie ustawia localhost i port 5000\n    # app.run(host='0.0.0.0', port=8000)\n\n\nUwaga! w dokumentacji Flask w przykładowym kodzie nie występują ostatnie dwie liniki uruchamiające serwer. Ponadto poleceniem uruchamiającym serwer jest flask run a nie python app.py.\n\nWyjaśnijmy co zawiera przykładowy kod.\n\nfrom flask import Flask Załadowanie biblioteki\napp = Flask(__name__) utworzenie interfejsu serwera API\nkod podstrony z wykorzystaniem dekoratora\n\n@app.route('/')\ndef say_hello():\n    return \"Hello World\"\nW celu pokazania jak działa dekorator zdefiniujmy następującą funkcję:\n\ndef make_pretty(func):\n    def inner():\n        print(\"decorator działa\")\n        func()\n    return inner()\n\nNastępnie funkcja testowa\n\ndef test():\n    print(\"abc\")\n\nmake_pretty(test)\n\ndecorator działa\nabc\n\n\nAle mozna rowniez inaczej\n\n@make_pretty\ndef test2():\n    print(\"test2\")\n\ndecorator działa\ntest2\n\n\n\n@make_pretty\ndef test3():\n    print(\"jeszcze cos\")\n\ndecorator działa\njeszcze cos",
    "crumbs": [
      "222890-D",
      "Ćwiczenia",
      "Środowisko produkcyjne z modelem ML"
    ]
  },
  {
    "objectID": "lab/cw1.html#środowisko-python",
    "href": "lab/cw1.html#środowisko-python",
    "title": "Środowisko produkcyjne z modelem ML",
    "section": "Środowisko Python",
    "text": "Środowisko Python\nAby kod aplikacji app.py mógł zostać uruchomiony potrzebujemy aby na naszym komputerze istniał jakiś interpreter języka Python. Samo posiadanie interpretatora nie jest jeszcze wystarczające dla naszej aplikacji. Do pełnego uruchomienia potrzebujemy wygenerować środowisko (najlepiej wirtualne) w który dostępne będą wszystkie potrzebne biblioteki (np. flask).\n\nuwaga: wszystkie polecenia terminala dotyczyć będą wersji linux/mac os.\n\nW pierwszej kolejności sprawdź czy dostępne są polecenia pozwalające realizować kod pythonowy.\nwhich python\nwhich python3\nwhich pip \nwhich pip3\nWszystkie te polecenia powinny wskazyać na folder z domyślnym środowiskiem Pythona.\nWygeneruj i uruchom środowisko wirtualne lokalnie wpisując w terminalu:\npython3 -m venv .venv\nsource .venv/bin/activate\n\nDobra praktyka: środowisko python to nic innego jak katalog. W naszej wersji to katalog ukryty o nazwie .venv. Jeśli skopiujesz ten katalog gdzie indziej przestanie pełnić on swoją funkcję środowiska python. Dlatego jego odtworzenie nie polega na jego kopiowaniu. Jeśli Twój projekt jest powiązany ze środowiskiem kontroli wersji GIT zadbaj aby katalog środowiska nie był dodawany do repozytorium. Mozesz wykonać to działanie dodając odpowiedni wpis do pliki .gitignore\n\nPosiadając utworzone nowe środowisko sprawdź jakie biblioteki się w nim znajdują.\npip list \n\nPackage    Version\n---------- -------\npip        23.2.1\npyspark    3.4.1\nsetuptools 65.5.0\nMozemy ponownie sprawdzić polecenia python i pip\nwhich python\nwhich pip \nDomyślnie powinny pojawić się biblioteki pip oraz setuptools (pyspark pochodzi z naszego wewnętrzengo obrazu).\nDoinstaluj bibliotekę flask\npip install flask\npip list \nPackage      Version\n------------ -------\nblinker      1.7.0\nclick        8.1.7\nFlask        3.0.3\nitsdangerous 2.1.2\nJinja2       3.1.3\nMarkupSafe   2.1.5\npip          23.2.1\npyspark      3.4.1\nsetuptools   65.5.0\nWerkzeug     3.0.2\nJak widać instalacja biblioteki flask wymusiła doinstalowanie równiez innych pakietów.\nJedyną mozliwością przeniesienia środowiska python jest jego instalacja na nowej maszynie i instalacja wszystkich pakietów ręcznie. Aby jednak nie instalować kazdego pakietu osobno mozemy wykorzystać plik requirements.txt konfiguracyjny z listą pakietów.\n\nPamiętaj - kazdy pakiet powinien zawierać nr wersji pakietu. W innym przypadku moze okazać się, ze nowe werjse pakietów powodują brak obsługi twojego kodu.\n\nAby utworzyć plik konfiguracyjny uzyj polecenia w terminalu:\npip freeze &gt;&gt; requirements.txt\nTak wygenerowany plik mozesz uzywać na dowolnej maszynie do instalacji i odtworzenia potrzebnego środowiska wykonawczego python.\n\nDygresja. W momencie przygotowywania materiałów Flask był w wersji 3.0.1 - dziś juz realizowany jest w wersji 3.0.3.\n\nInstalacja pakietów z pliku odbywa się z wykorzystaniem polecenia:\npip install -r requierements.txt\nMamy teraz dwa pliki: app.py, i requirements.txt. Przenosząc je do dowolnego projektu na serwerach github jesteśmy w stanie uruchomić naszą aplikację wszędzie tam gdzie dostępny będzie interpreter python na którym mozemy utworzyć nowe wirtualne środowisko i zainstalować biblioteki z pliku requirements.txt.\nDo pełnej automatyzacji przydałaby się jeszcze mozliwość uruchomienia środowiska python na dowolnej maszynie.\nW tym celu utwórz plik Dockerfile:\n\n%%file Dockerfile\nFROM python:3.11-slim-buster\n\nWORKDIR /app\n\nCOPY requirements.txt requirements.txt\n\nRUN pip install -r requirements.txt\n\nCOPY app.py .\n\nENV FLASK_APP=app\n\nEXPOSE 8000\nCMD [\"flask\", \"run\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\n\nPowyzszy plik pozwala w docker desktop uruchomić obraz wykorzystujący podstawowy system operacyjny (tutaj linux) wraz z podstawowym środowiskiem python3.11.\nPonadto plik ten kopiuje potrzebne pliki (app.py, requirements.txt) na obraz dockera.\nPolecenie RUN pozwala uruchomić dowolne polecenie bash wewnątrz obrazu dockera.\nPolecenie CMD pozwala uruchomić polecenie uruchamiające serwer w trybie tak by nie zamknąć tego polecenia.\nOstatnią informacją jest ustalenie portu na 8000.\n# utworzenie kontenera na podstawie pliku Dockerfile\ndocker build -t modelML .\n# uruchomienie kontenera\ndocker run -p 8000:8000 modelML",
    "crumbs": [
      "222890-D",
      "Ćwiczenia",
      "Środowisko produkcyjne z modelem ML"
    ]
  },
  {
    "objectID": "lab/cw1.html#uruchomienie-serwera-lokalnie",
    "href": "lab/cw1.html#uruchomienie-serwera-lokalnie",
    "title": "Środowisko produkcyjne z modelem ML",
    "section": "Uruchomienie serwera lokalnie",
    "text": "Uruchomienie serwera lokalnie\nUruchomienie serwera moze odbyć się na przynajmniej na dwa sposoby.\n\nUruchomienie serwera przez terminal\npython app.py\nlub (jeśli nie ma kodu app.run() uruchamiającego serwer.)\nflask run \nPowinna pojawić się informacja podobna do ponizszej:\n * Serving Flask app 'app'\n * Debug mode: off\nWARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.\n * Running on http://127.0.0.1:5000\nPress CTRL+C to quit\n\n\nUruchomienie serwera przez notatnik\nBezpośrenie uruchomienia kodu w notatniku spowoduje uruchomienie serwera i zatrzymanie jakiejkolwiek mozliwości realizacji kodu. Aby tego uniknąć mozesz wykorzystać bibliotekę subprocess.\n\nimport subporcess\n\np = subprocess.Popen([\"python\", \"app.py\"])\n\nJeśli potrzebujemy zamknąć subprocess wykonaj:\n\np.kill()\n\nPosiadając uruchomiony serwer mozesz odpytac serwer wykorzystując:\ncurl localhost:5000\nalbo kod w notatniku:\n\nimport requests\n\nresponse = requests.get(\"http://127.0.0.1:5000/\")\n\nprint(response.content) # Hello World\nprint(response.status_code) # 200",
    "crumbs": [
      "222890-D",
      "Ćwiczenia",
      "Środowisko produkcyjne z modelem ML"
    ]
  },
  {
    "objectID": "lab/cw4.html",
    "href": "lab/cw4.html",
    "title": "dane nieustruktyryzowane",
    "section": "",
    "text": "Dane nieustrukturyzowane to dane, które nie są w żaden sposób uporządkowane.\nNiezależnie od typu wszystko przetwarzamy w tensorach (macierzach wielowymiarowych). Może to prowadzić do chęci używania modeli ML i sieci neuronowych do analizy danych nieustrukturyzowanych.\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nsns.set(style=\"whitegrid\", palette=\"husl\")\n\n\n# 2-dim picture 28 x 28 pixel\npicture_2d = np.random.uniform(size=(28,28))\npicture_2d[0:5,0:5]\n\narray([[0.75586744, 0.84583516, 0.31174781, 0.56986022, 0.54521732],\n       [0.4509245 , 0.12609184, 0.5827946 , 0.4015805 , 0.90850987],\n       [0.59563304, 0.52120978, 0.7381324 , 0.73338458, 0.69635556],\n       [0.91483631, 0.03408766, 0.58924087, 0.74936144, 0.45536234],\n       [0.24416936, 0.95129512, 0.31760295, 0.87146642, 0.59493202]])\nplt.imshow(picture_2d, interpolation='nearest')\nplt.show()",
    "crumbs": [
      "222890-D",
      "Ćwiczenia",
      "dane nieustruktyryzowane"
    ]
  },
  {
    "objectID": "lab/cw4.html#format-json",
    "href": "lab/cw4.html#format-json",
    "title": "dane nieustruktyryzowane",
    "section": "Format json",
    "text": "Format json\nTwórz i zarządzaj jsonami w połączeniu z bazą danych mongoDB. Baza ta dostępna jest jako osobny mikroserwis w Dockerze. Przed podłączeniem sprawdź jak w pliku docker-compose.yml jest skonfigurowany serwis mongoDB (user i pass).\n\nimport json\nperson = '{\"name\": \"Alice\", \"languages\": [\"English\", \"French\"]}'\nperson_dict = json.loads(person)\n\nprint(person_dict)\n\n{'name': 'Alice', 'languages': ['English', 'French']}\n\n\n\n%%file test.json\n{\"name\": \"Alice\", \"languages\": [\"English\", \"French\"]}\n\nWriting test.json\n\n\n\nwith open('test.json') as f:\n    data = json.load(f)\n\nprint(data)\n\n{'name': 'Alice', 'languages': ['English', 'French']}\n\n\n\nwith open('person.json', 'w') as json_file:\n    json.dump(person_dict, json_file)\n\n\n# do połączenia używamy biblioteki pymongo\n!pip install pymongo -q --user\n\n\nfrom pymongo import MongoClient\nuri = \"mongodb://root:admin@mongo\"\nclient = MongoClient(uri)\n\n\ndb = client['school']\n\n\nstudents = db.students\nnew_students = [\n    {'name': 'John', 'surname': 'Smith', 'group': '1A', 'age': 22, 'skills': ['drawing', 'skiing']},\n    {'name': 'Mike', 'surname': 'Jones', 'group': '1B', 'age': 24, 'skills': ['chess', 'swimming']},\n    {'name': 'Diana', 'surname': 'Williams', 'group': '2A', 'age': 28, 'skills': ['curling', 'swimming']},\n    {'name': 'Samantha', 'surname': 'Brown', 'group': '1B', 'age': 21, 'skills': ['guitar', 'singing']}\n]\n\n\nstudents.insert_many(new_students)\n\nInsertManyResult([ObjectId('66362867602f731cf8df3a3a'), ObjectId('66362867602f731cf8df3a3b'), ObjectId('66362867602f731cf8df3a3c'), ObjectId('66362867602f731cf8df3a3d')], acknowledged=True)\n\n\n\nstudents.find_one()\n\n{'_id': ObjectId('66362867602f731cf8df3a3a'),\n 'name': 'John',\n 'surname': 'Smith',\n 'group': '1A',\n 'age': 22,\n 'skills': ['drawing', 'skiing']}\n\n\nznajdz inne metody realizujące select * from table where...",
    "crumbs": [
      "222890-D",
      "Ćwiczenia",
      "dane nieustruktyryzowane"
    ]
  },
  {
    "objectID": "lab/cw4.html#tekst",
    "href": "lab/cw4.html#tekst",
    "title": "dane nieustruktyryzowane",
    "section": "tekst",
    "text": "tekst\n\nimport pandas as pd\ndf_train = pd.read_csv(\"train.csv\")\ndf_train = df_train.drop(\"index\", axis=1)\nprint(df_train.head())\nprint(np.bincount(df_train[\"label\"]))\n\n                                                text  label\n0  When we started watching this series on cable,...      1\n1  Steve Biko was a black activist who tried to r...      1\n2  My short comment for this flick is go pick it ...      1\n3  As a serious horror fan, I get that certain ma...      0\n4  Robert Cummings, Laraine Day and Jean Muir sta...      1\n[17452 17548]\n\n\n\n# BoW model  - wektoryzator z sklearn\nfrom sklearn.feature_extraction.text import CountVectorizer\n\ncv = CountVectorizer(lowercase=True, max_features=10_000, stop_words=\"english\")\n\ncv.fit(df_train[\"text\"])\n\nCountVectorizer(max_features=10000, stop_words='english')In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.CountVectorizerCountVectorizer(max_features=10000, stop_words='english')\n\n\n\n# słownik i nasze zmienne ..\ncv.vocabulary_\n\n{'started': 8515,\n 'watching': 9725,\n 'series': 7957,\n 'cable': 1320,\n 'idea': 4488,\n 'hate': 4191,\n 'character': 1544,\n 'hold': 4339,\n 'beautifully': 892,\n 'developed': 2574,\n 'understand': 9375,\n 'react': 7196,\n 'frustration': 3737,\n 'fear': 3439,\n 'greed': 4020,\n 'temptation': 8974,\n 'way': 9736,\n 'viewer': 9574,\n 'experiencing': 3280,\n 'christopher': 1656,\n 'learning': 5199,\n 'br': 1151,\n 'abuse': 188,\n 'physically': 6608,\n 'emotionally': 3046,\n 'just': 4963,\n 'read': 7199,\n 'newspaper': 6088,\n 'women': 9880,\n 'tolerate': 9134,\n 'behavior': 915,\n 'dream': 2831,\n 'house': 4418,\n 'endless': 3074,\n 'supply': 8779,\n 'expensive': 3276,\n 'things': 9036,\n 'sure': 8791,\n 'loving': 5426,\n 'faithful': 3371,\n 'husband': 4465,\n 'maybe': 5640,\n 'watch': 9719,\n 'doesn': 2754,\n 'matter': 5630,\n 'times': 9104,\n 'episode': 3140,\n 'missed': 5813,\n 'episodes': 3141,\n 'sequence': 7950,\n 'season': 7869,\n 'late': 5151,\n 'night': 6101,\n 'commercials': 1874,\n 'language': 5133,\n 'reruns': 7427,\n 'movie': 5938,\n 'network': 6077,\n 've': 9529,\n 'totally': 9171,\n 'spoiled': 8437,\n 'love': 5420,\n 'neck': 6044,\n 'favorite': 3431,\n 'johnny': 4906,\n 'boy': 1144,\n 'entered': 3112,\n 'family': 3386,\n 'sign': 8134,\n 'life': 5270,\n 'ends': 3076,\n 'collected': 1816,\n 'dvd': 2910,\n 'collection': 1818,\n 'steve': 8566,\n 'biko': 984,\n 'black': 1014,\n 'tried': 9269,\n 'resist': 7440,\n 'white': 9800,\n 'minority': 5793,\n 'south': 8365,\n 'africa': 322,\n 'gandhi': 3787,\n 'british': 1209,\n 'empire': 3054,\n 'india': 4604,\n 'richard': 7523,\n 'attenborough': 701,\n 'film': 3509,\n 'freedom': 3707,\n 'donald': 2773,\n 'woods': 9894,\n 'liberal': 5260,\n 'editor': 2967,\n 'trying': 9302,\n 'tell': 8966,\n 'story': 8605,\n 'jarring': 4858,\n 'point': 6709,\n 'view': 9572,\n 'switch': 8855,\n 'dies': 2609,\n 'prison': 6908,\n 'hands': 4136,\n 'african': 323,\n 'police': 6725,\n 'played': 6677,\n 'kevin': 5007,\n 'kline': 5057,\n 'choose': 1632,\n 'right': 7544,\n 'thing': 9035,\n 'flee': 3575,\n 'country': 2133,\n 'books': 1102,\n 'allow': 405,\n 'wife': 9816,\n 'penelope': 6526,\n 'pressure': 6873,\n 'forgetting': 3650,\n 'case': 1443,\n 'vain': 9499,\n 'begins': 908,\n 'changing': 1535,\n 'friendship': 3723,\n 'standard': 8495,\n 'numbers': 6182,\n 'escape': 3162,\n 'border': 1109,\n 'yarn': 9958,\n 'death': 2390,\n 'oscar': 6320,\n 'nominated': 6124,\n 'denzel': 2497,\n 'washington': 9713,\n 'good': 3942,\n 'fourth': 3675,\n 'wrong': 9944,\n 'tries': 9271,\n 'depict': 2505,\n 'struggles': 8653,\n 'focusing': 3610,\n 'trials': 9261,\n 'half': 4117,\n 'served': 7963,\n 'topic': 9155,\n 'better': 965,\n 'rise': 7561,\n 'instead': 4695,\n 'beginning': 907,\n 'actor': 241,\n 'leading': 5190,\n 'role': 7609,\n 'hour': 4416,\n 'wasn': 9714,\n 'exactly': 3220,\n 'big': 975,\n 'box': 1140,\n 'office': 6244,\n 'tremendous': 9255,\n 'flop': 3594,\n 'politics': 6736,\n 'aside': 639,\n 'entertains': 3121,\n 'sends': 7922,\n 'message': 5722,\n 'albeit': 372,\n 'pg': 6580,\n 'fashion': 3412,\n 'stars': 8512,\n 'short': 8087,\n 'comment': 1866,\n 'flick': 3583,\n 'pick': 6613,\n 'chances': 1529,\n 'going': 3930,\n 'positively': 6779,\n 'surprised': 8801,\n 'diversity': 2732,\n 'elements': 3010,\n 'superbly': 8768,\n 'explored': 3304,\n 'criminal': 2209,\n 'thriller': 9066,\n 'claiming': 1697,\n 'pushing': 7062,\n 'room': 7630,\n 'possible': 6788,\n 'wont': 9890,\n 'push': 7059,\n 'nerves': 6071,\n 'edge': 2957,\n 'thumbs': 9081,\n 'horror': 4403,\n 'fan': 3388,\n 'certain': 1509,\n 'marketing': 5572,\n 'used': 9480,\n 'sell': 7910,\n 'movies': 5940,\n 'especially': 3166,\n 'really': 7222,\n 'bad': 789,\n 'ones': 6268,\n 'wouldn': 9922,\n 'assumed': 667,\n 'ripping': 7559,\n 'cannibal': 1365,\n 'zombi': 9993,\n 'jungle': 4957,\n 'holocaust': 4352,\n 'unfortunately': 9405,\n 'completely': 1916,\n 'hardcore': 4160,\n 'realized': 7219,\n 'saw': 7777,\n 'odd': 6229,\n 'actual': 246,\n 'minor': 5792,\n 'warning': 9701,\n 'notice': 6156,\n 'daring': 2344,\n 'catch': 1461,\n 'group': 4057,\n 'scientists': 7822,\n 'pretty': 6880,\n 'led': 5207,\n 'sea': 7858,\n 'captain': 1383,\n 'penchant': 6525,\n 'beach': 876,\n 'search': 7864,\n 'mutated': 5982,\n 'native': 6021,\n 'killing': 5029,\n 'villagers': 9586,\n 'nuclear': 6178,\n 'bomb': 1084,\n 'supposedly': 8788,\n 'island': 4814,\n 'radiation': 7113,\n 'turned': 9315,\n 'man': 5521,\n 'rapist': 7170,\n 'killer': 5027,\n 'writer': 9939,\n 'george': 3845,\n 'succeeds': 8717,\n 'keeping': 4994,\n 'clothes': 1767,\n 'sex': 7984,\n 'scenes': 7802,\n 'whacked': 9787,\n 'walk': 9661,\n 'nude': 6179,\n 'strange': 8613,\n 'asks': 643,\n 'rape': 7164,\n 'turns': 9318,\n 'chicks': 1610,\n 'slapping': 8222,\n 'naturally': 6024,\n 'scene': 7800,\n 'chick': 1608,\n 'toss': 9168,\n 'finger': 3530,\n 'know': 5071,\n 'rest': 7458,\n 'insane': 4667,\n 'oh': 6251,\n 'kidding': 5017,\n 'ton': 9140,\n 'like': 5287,\n 'pays': 6507,\n 'guys': 4095,\n 'tag': 8887,\n 'team': 8940,\n 'taking': 8894,\n 'use': 9479,\n 'cuts': 2293,\n 'refuses': 7296,\n 'advances': 295,\n 'starts': 8519,\n 'crying': 2254,\n 'gentleman': 3839,\n 'reluctantly': 7349,\n 'lets': 5248,\n 'pleasure': 6688,\n 'crew': 2204,\n 'members': 5690,\n 'honestly': 4368,\n 'waiting': 9655,\n 'pizza': 6649,\n 'guy': 4094,\n 'ask': 640,\n 'pay': 6503,\n 'happens': 4152,\n 'conduct': 1953,\n 'research': 7431,\n 'wait': 9653,\n 'thought': 9050,\n 'zombie': 9994,\n 'enter': 3111,\n 'mark': 5568,\n 'time': 9101,\n 'plenty': 6690,\n 'hitting': 4330,\n 'fast': 3416,\n 'forward': 3670,\n 'splatter': 8430,\n 'porn': 6756,\n 'don': 2772,\n 'think': 9037,\n 'does': 2753,\n 'justice': 4964,\n 'guess': 4072,\n 'woman': 9879,\n 'talking': 8905,\n 'say': 7779,\n 'plot': 6694,\n 'hairy': 4114,\n 'funny': 3759,\n 'worked': 9900,\n 'decent': 2404,\n 'atomic': 687,\n 'bombing': 1086,\n 'bitter': 1011,\n 'shakes': 8006,\n 'head': 4213,\n 'walks': 9666,\n 'away': 758,\n 'couple': 2138,\n 'makes': 5510,\n 'wonder': 9882,\n 'disgusted': 2693,\n 'feel': 3454,\n 'sound': 8355,\n 'quality': 7073,\n 'guessed': 4073,\n 'production': 6929,\n 'shot': 8092,\n 'including': 4587,\n 'erotic': 3157,\n 'nights': 6106,\n 'living': 5344,\n 'dead': 2377,\n 'sports': 8450,\n 'cast': 1453,\n 'said': 7716,\n 'wanted': 9685,\n 'vacation': 9495,\n 'paycheck': 6504,\n 'suddenly': 8728,\n 'weird': 9767,\n 'speaking': 8388,\n 'italian': 4824,\n 'recorded': 7255,\n 'english': 3092,\n 'dialogue': 2591,\n 'people': 6532,\n 'clearly': 1724,\n 'hear': 4223,\n 'background': 781,\n 'yes': 9970,\n 'wonderful': 9884,\n 'slightly': 8248,\n 'amusing': 454,\n 'score': 7827,\n 'couldn': 2124,\n 'save': 7772,\n 'sfx': 7992,\n 'minimal': 5785,\n 'best': 959,\n 'consisted': 2006,\n 'blood': 1050,\n 'violent': 9596,\n 'bright': 1199,\n 'label': 5099,\n 'cover': 2150,\n 'ploy': 6698,\n 'presented': 6865,\n 'widescreen': 9810,\n '85': 153,\n 'aspect': 645,\n 'ratio': 7181,\n 'watched': 9721,\n 'region': 7304,\n 'rated': 7176,\n 'version': 9549,\n 'running': 7683,\n 'released': 7334,\n '2005': 104,\n 'exploitation': 3298,\n 'digital': 2623,\n 'apparently': 538,\n 'doubt': 2790,\n 'different': 2616,\n 'shouldn': 8097,\n '25': 116,\n '00': 0,\n 'copy': 2094,\n 'recommend': 7250,\n 'pretend': 6876,\n 'exist': 3256,\n 'quote': 7098,\n 'civilians': 1691,\n 'luck': 5441,\n 'monsters': 5879,\n 'extras': 3331,\n 'original': 6311,\n 'trailer': 9204,\n 'shots': 8094,\n 'kills': 5032,\n 'make': 5507,\n 'look': 5387,\n 'interesting': 4733,\n 'trailers': 9205,\n 'ss': 8467,\n 'hell': 4251,\n 'camp': 1346,\n 'informative': 4642,\n 'interview': 4750,\n 'line': 5308,\n 'lame': 5119,\n 'porno': 6757,\n 'weaker': 9741,\n 'real': 7207,\n 'rating': 7179,\n '10': 3,\n 'molly': 5856,\n 'www': 9954,\n 'com': 1836,\n 'robert': 7588,\n 'cummings': 2268,\n 'day': 2371,\n 'jean': 4866,\n 'star': 8503,\n 'beautiful': 891,\n '1940': 31,\n 'starring': 8511,\n 'billie': 986,\n 'burke': 1282,\n '15': 12,\n 'minutes': 5797,\n 'looks': 5390,\n 'playboy': 6676,\n 'desire': 2541,\n 'sisters': 8181,\n 'katherine': 4982,\n 'helen': 4248,\n 'likes': 5291,\n 'fix': 3554,\n 'cars': 1435,\n 'blonde': 1048,\n 'social': 8302,\n 'butterfly': 1307,\n 'arrives': 612,\n 'town': 9182,\n 'believing': 930,\n 'party': 6464,\n 'decides': 2409,\n 'attend': 702,\n 'given': 3892,\n 'friend': 3720,\n 'mother': 5916,\n 'dress': 2837,\n 'connect': 1976,\n 'sees': 7899,\n 'dinner': 2634,\n 'left': 5210,\n 'club': 1772,\n 'terribly': 8995,\n 'drunk': 2869,\n 'ride': 7533,\n 'car': 1391,\n 'won': 9881,\n 'let': 5245,\n 'drive': 2851,\n 'walking': 9665,\n 'awhile': 764,\n 'breaking': 1175,\n 'shoe': 8077,\n 'gets': 3859,\n 'drives': 2856,\n 'passes': 6472,\n 'takes': 8893,\n 'wheel': 9791,\n 'accidentally': 206,\n 'remember': 7364,\n 'blame': 1021,\n 'sister': 8180,\n 'shoes': 8078,\n 'plus': 6701,\n 'manner': 5540,\n 'realize': 7218,\n 'isn': 4816,\n 'telling': 8967,\n 'truth': 9298,\n 'convicted': 2071,\n 'goes': 3929,\n 'marries': 5580,\n 'leaves': 5204,\n 'america': 439,\n 'list': 5325,\n 'playing': 6681,\n 'taylor': 8932,\n 'mgm': 5737,\n 'handsome': 4137,\n 'amiable': 442,\n 'dazzling': 2375,\n 'actress': 243,\n 'constantly': 2014,\n 'didn': 2603,\n 'great': 4013,\n 'face': 3343,\n 'voice': 9626,\n 'determined': 2569,\n 'sympathetic': 8871,\n 'lovely': 5422,\n 'lousy': 5418,\n 'highly': 4296,\n 'recommended': 7252,\n 'little': 5337,\n 'gem': 3819,\n 'dark': 2345,\n 'overlooked': 6359,\n 'known': 5074,\n 'early': 2927,\n '80': 151,\n 'deserves': 2535,\n 'audience': 717,\n 'damn': 2320,\n 'shame': 8013,\n 'seen': 7898,\n 'compared': 1893,\n 'gotten': 3965,\n 'bigger': 977,\n 'years': 9964,\n 'notably': 6150,\n 'comparisons': 1897,\n 'bit': 1003,\n 'similar': 8147,\n 'slipped': 8252,\n 'acceptance': 198,\n 'remake': 7358,\n 'breathe': 1181,\n 'new': 6082,\n 'unless': 9426,\n 'drained': 2816,\n 'remakes': 7359,\n 'days': 2373,\n 'work': 9899,\n 'lesser': 5240,\n 'films': 3516,\n 'awful': 761,\n 'ghost': 3863,\n 'ship': 8064,\n 'opening': 6275,\n 'falling': 3377,\n 'utter': 9492,\n 'crap': 2169,\n 'happen': 4148,\n 'fall': 3375,\n 'lot': 5410,\n 'haven': 4201,\n 'bring': 1204,\n 'course': 2143,\n 'got': 3961,\n 'eyes': 3338,\n 'anyways': 526,\n 'fans': 3392,\n 'cause': 1474,\n 'creepy': 2203,\n 'setting': 7972,\n 'fairly': 3367,\n 'acting': 234,\n 'campy': 1354,\n 'want': 9684,\n 'nudity': 6180,\n 'gore': 3954,\n 'sorry': 8347,\n 'nonetheless': 6128,\n 'solid': 8315,\n 'enjoy': 3099,\n 'grave': 4006,\n 'robber': 7583,\n 'sitting': 8188,\n 'cell': 1491,\n 'awaiting': 750,\n 'execution': 3251,\n 'visited': 9612,\n 'monk': 5868,\n 'wishing': 9860,\n 'words': 9897,\n 'horrible': 4397,\n 'lead': 5187,\n 'reluctant': 7348,\n 'tongue': 9144,\n 'drink': 2847,\n 'young': 9975,\n 'soon': 8334,\n 'undead': 9366,\n 'bump': 1275,\n 'york': 9974,\n 'filmed': 3510,\n 'brought': 1228,\n 'spirit': 8424,\n 'andy': 467,\n 'milligan': 5769,\n 'lurking': 5457,\n 'comedies': 1850,\n 'come': 1845,\n 'rate': 7175,\n 'dominic': 2770,\n 'plays': 6682,\n 'arthur': 619,\n 'blake': 1020,\n 'ron': 7626,\n 'father': 3423,\n 'statement': 8523,\n 'getting': 3860,\n 'involved': 4786,\n 'tale': 8896,\n 'men': 5695,\n 'having': 4202,\n 'grand': 3985,\n 'old': 6256,\n 'shows': 8109,\n 'equally': 3145,\n 'music': 5972,\n 'jeff': 4869,\n 'grace': 3972,\n 'excellent': 3230,\n 'effects': 2979,\n 'perfect': 6539,\n 'sort': 8348,\n 'silliness': 8143,\n 'deal': 2381,\n 'fun': 3747,\n 'trouble': 9288,\n 'throws': 9076,\n 'net': 6075,\n 'wide': 9807,\n 'result': 7465,\n 'needed': 6047,\n 'alien': 389,\n 'body': 1075,\n 'mix': 5830,\n 'theaters': 9018,\n 'later': 5153,\n 'll': 5347,\n 'worth': 9918,\n 'liked': 5289,\n 'script': 7851,\n 'changed': 1533,\n 'reason': 7225,\n 'rodney': 7603,\n 'dangerfield': 2334,\n 'jackie': 4837,\n 'mason': 5605,\n 'did': 2602,\n 'alot': 413,\n 'kept': 5004,\n 'flaw': 3571,\n 'dan': 2324,\n 'murray': 5968,\n 'carl': 1411,\n 'quit': 7096,\n 'job': 4898,\n 'assistant': 659,\n 'joined': 4909,\n 'military': 5764,\n 'warner': 9700,\n 'bros': 1224,\n 'ii': 4509,\n 'try': 9301,\n 'seeing': 7893,\n 'possibly': 6789,\n 'disappointed': 2662,\n 'fact': 3349,\n 'director': 2646,\n 'cube': 2260,\n 'comedy': 1851,\n 'imdb': 4531,\n 'spell': 8405,\n 'word': 9896,\n 'reminiscent': 7373,\n 'builds': 1263,\n 'slowly': 8258,\n 'gradually': 3976,\n 'explanation': 3291,\n 'mainly': 5500,\n 'set': 7970,\n 'respects': 7452,\n 'probably': 6915,\n 'commented': 1870,\n 'masterpiece': 5614,\n 'spanish': 8378,\n 'cinema': 1673,\n 'masters': 5616,\n 'piece': 6623,\n 'long': 5383,\n 'ago': 338,\n 'midnight': 5753,\n 'cowboy': 2158,\n 'les': 5236,\n 'du': 2872,\n 'realistic': 7213,\n 'non': 6127,\n 'spot': 8451,\n 'trainspotting': 9210,\n 'hard': 4159,\n 'place': 6650,\n 'humour': 4446,\n 'obviously': 6214,\n 'dramatic': 2820,\n 'sense': 7926,\n 'diamond': 2593,\n 'resurrection': 7470,\n 'neo': 6064,\n 'realism': 7211,\n 'mixed': 5831,\n 'ken': 4999,\n 'discover': 2677,\n 'modern': 5849,\n 'tv': 9320,\n 'classic': 1709,\n 'bob': 1072,\n 'girlfriend': 3889,\n 'named': 6003,\n 'alicia': 388,\n 'married': 5579,\n 'bud': 1247,\n 'owen': 6375,\n 'works': 9904,\n 'jealous': 4864,\n 'hanging': 4140,\n 'hangs': 4141,\n 'secretary': 7881,\n 'heather': 4237,\n 'accident': 204,\n 'prone': 6970,\n 'kind': 5035,\n 'lonely': 5380,\n 'wishes': 9859,\n 'friends': 3722,\n 'end': 3069,\n 'looked': 5388,\n 'finally': 3521,\n 'went': 9776,\n 'driving': 2857,\n 'wedding': 9759,\n 'making': 5512,\n 'tiny': 9110,\n 'stuck': 8658,\n 'middle': 5750,\n 'happened': 4149,\n 'poor': 6744,\n 'ended': 3071,\n 'guide': 4078,\n 'fox': 3676,\n 'twice': 9323,\n 'putting': 7064,\n 'air': 356,\n 'loved': 5421,\n 'cool': 2082,\n 'glasses': 3901,\n 'hilarious': 4298,\n 'miss': 5812,\n 'reading': 7203,\n 'book': 1101,\n 'ending': 3072,\n 'missing': 5817,\n 'sad': 7707,\n 'treatment': 9250,\n 'subject': 8692,\n 'quite': 7097,\n 'controversial': 2055,\n 'comments': 1872,\n 'distinction': 2712,\n 'based': 845,\n 'believe': 926,\n 'portrayed': 6768,\n 'basically': 850,\n 'sequels': 7949,\n '30': 122,\n 'values': 9507,\n 'plan': 6658,\n 'outer': 6331,\n 'space': 8370,\n 'level': 5253,\n 'glen': 3902,\n 'glenda': 3903,\n 'ed': 2954,\n 'wood': 9892,\n 'religious': 7347,\n 'scary': 7796,\n 'add': 257,\n 'slightest': 8247,\n 'actually': 247,\n 'close': 1758,\n 'future': 3766,\n 'scarier': 7791,\n 'reasons': 7229,\n 'code': 1792,\n 'thief': 9033,\n 'explain': 3287,\n 'east': 2938,\n 'effect': 2976,\n 'happening': 4150,\n 'forget': 3647,\n 'stories': 8603,\n 'told': 9131,\n 'god': 3921,\n 'frightening': 3727,\n 'wild': 9818,\n 'rebels': 7234,\n 'frustrating': 3736,\n 'deals': 2385,\n 'race': 7104,\n 'driver': 2854,\n 'bikers': 982,\n 'called': 1331,\n 'satan': 7759,\n 'angels': 473,\n 'hang': 4139,\n 'decide': 2406,\n 'rob': 7581,\n 'bank': 818,\n 'cops': 2093,\n 'report': 7406,\n 'dated': 2360,\n 'carry': 1433,\n 'significantly': 8139,\n 'crude': 2247,\n 'stupid': 8679,\n 'band': 814,\n 'stage': 8477,\n 'performing': 6549,\n 'regular': 7308,\n 'generic': 3830,\n 'care': 1396,\n 'taken': 8891,\n 'filmmaker': 3512,\n 'logic': 5369,\n 'direction': 2643,\n 'actors': 242,\n 'parts': 6463,\n 'major': 5505,\n 'indifferent': 4612,\n 'unpredictable': 9439,\n 'comes': 1852,\n 'florida': 3595,\n 'ho': 4334,\n 'worthy': 9921,\n 'mystery': 5992,\n 'science': 7819,\n 'theater': 9017,\n '3000': 124,\n 'status': 8532,\n 'commentary': 1868,\n 'characters': 1550,\n 'screen': 7841,\n 'saying': 7780,\n 'pack': 6390,\n 'low': 5428,\n 'expectations': 3270,\n 'came': 1338,\n 'months': 5887,\n 'tragedy': 9200,\n 'open': 6273,\n 'wounds': 9925,\n 'thank': 9012,\n 'bravery': 1167,\n 'offered': 6240,\n 'closure': 1765,\n 'consider': 1998,\n 'hidden': 4285,\n 'frontier': 3731,\n 'somewhat': 8326,\n 'small': 8265,\n 'met': 5727,\n 'counting': 2130,\n 'conventions': 2062,\n '2001': 100,\n 'continue': 2036,\n 'impressed': 4559,\n 'self': 7908,\n 'studio': 8663,\n 'pictures': 6620,\n 'fancy': 3390,\n 'writers': 9940,\n 'walter': 9673,\n 'aka': 363,\n 'mr': 5942,\n 'manage': 5522,\n 'create': 2183,\n 'replacing': 7403,\n 'ghastly': 3861,\n 'experiment': 3281,\n 'enterprise': 3114,\n 'successful': 8719,\n 'arc': 571,\n 'introduction': 4765,\n 'trek': 9254,\n 'openly': 6276,\n 'gay': 3811,\n 'corey': 2098,\n 'introduced': 4762,\n 'second': 7876,\n 'soul': 8353,\n 'mate': 5622,\n 'meets': 5674,\n 'officer': 6245,\n 'recent': 7241,\n 'lines': 5312,\n 'spoiler': 8438,\n 'causing': 1477,\n 'change': 1532,\n 'conflict': 1964,\n 'relationship': 7325,\n 'uncertain': 9355,\n 'shown': 8108,\n 'chat': 1570,\n 'endure': 3077,\n 'gene': 3823,\n 'created': 2184,\n 'intention': 4723,\n 'flashy': 3566,\n 'battles': 868,\n 'popular': 6752,\n 'previous': 6886,\n 'stated': 8522,\n 'wish': 9857,\n 'higher': 4291,\n 'suffice': 8734,\n 'tradition': 9195,\n 'seven': 7978,\n 'generation': 3828,\n 'willing': 9829,\n 'bet': 960,\n 'final': 3519,\n 'debut': 2398,\n '1958': 50,\n 'enjoyed': 3101,\n 'leave': 5203,\n 'sons': 8332,\n 'harriet': 4176,\n 'dick': 2599,\n 'van': 9510,\n 'lucy': 5444,\n 'enjoying': 3102,\n 'donna': 2774,\n 'reed': 7273,\n 'stone': 8590,\n 'intelligent': 4714,\n 'mannered': 5541,\n 'problem': 6916,\n 'solving': 8321,\n 'stay': 8533,\n 'home': 4356,\n 'mom': 5857,\n 'june': 4956,\n 'contrast': 2045,\n 'ms': 5944,\n 'dad': 2304,\n 'boxing': 1143,\n 'teaching': 8939,\n 'son': 8327,\n 'defend': 2430,\n 'larger': 5141,\n 'bully': 1271,\n 'mothers': 5917,\n 'neighborhood': 6056,\n 'grew': 4030,\n 'idealistic': 4490,\n 'standards': 8496,\n 'refreshing': 7291,\n 'manners': 5543,\n 'decision': 2411,\n 'today': 9124,\n 'accepted': 199,\n 'indifference': 4611,\n 'neighbors': 6057,\n 'imagine': 4528,\n 'mary': 5599,\n 'parents': 6443,\n 'okay': 6254,\n 'leaving': 5205,\n 'dog': 2755,\n 'outside': 6345,\n 'acceptable': 197,\n 'shut': 8114,\n 'supermarket': 8775,\n 'cinematography': 1678,\n 'highlights': 4295,\n 'true': 9292,\n 'account': 216,\n '1950s': 43,\n ...}\n\n\n\nX_train = cv.transform(df_train[\"text\"])\n\n\n# to dense matrix\nfeat_vec = np.array(X_train[0].todense())[0]\nprint(feat_vec.shape)\nnp.bincount(feat_vec)\n\n(10000,)\n\n\narray([9926,   67,    5,    0,    1,    0,    1])",
    "crumbs": [
      "222890-D",
      "Ćwiczenia",
      "dane nieustruktyryzowane"
    ]
  },
  {
    "objectID": "lab/cw4.html#obiektowe-podejście-do-modelowania",
    "href": "lab/cw4.html#obiektowe-podejście-do-modelowania",
    "title": "dane nieustruktyryzowane",
    "section": "Obiektowe podejście do modelowania",
    "text": "Obiektowe podejście do modelowania\n\nimport pandas as pd\nimport numpy as np\n \n# przykład danych ustrukturyzowanych\ndf = pd.read_csv(\"students.csv\")\ndf.head()\n\n\n\n\n\n\n\n\n\nsex\nrace/ethnicity\nparental level of education\nlunch\ntest preparation course\nmath score\nreading score\nwriting score\ntarget\n\n\n\n\n0\nfemale\ngroup B\nbachelor's degree\nstandard\nnone\n72\n72\n74\n0\n\n\n1\nfemale\ngroup C\nsome college\nstandard\ncompleted\n69\n90\n88\n1\n\n\n2\nfemale\ngroup B\nmaster's degree\nstandard\nnone\n90\n95\n93\n0\n\n\n3\nmale\ngroup A\nassociate's degree\nfree/reduced\nnone\n47\n57\n44\n1\n\n\n4\nmale\ngroup C\nsome college\nstandard\nnone\n76\n78\n75\n0\n\n\n\n\n\n\n\n\n\nlen(df), list(df.columns)\n\n(99,\n ['sex',\n  'race/ethnicity',\n  'parental level of education',\n  'lunch',\n  'test preparation course',\n  'math score',\n  'reading score',\n  'writing score',\n  'target'])\n\n\n\nX = df.drop(columns=['target'])\ny = df['target']\n\n\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.compose import ColumnTransformer\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.impute import SimpleImputer\nfrom sklearn.preprocessing import OneHotEncoder\n\n# ZAMIAST OD RAZU PRZETWARZAC !!! najpierw przygotuj kroki - pipeline\n\nnumeric_features = ['math score','reading score','writing score']\ncategorical_features = ['sex','race/ethnicity','parental level of education','lunch','test preparation course']\n\n\nnumeric_transformer = Pipeline(steps=[\n    (\"imputer\", SimpleImputer(strategy=\"mean\")),\n    (\"scaler\", StandardScaler())\n])\n\ncategorical_transformer = OneHotEncoder(handle_unknown=\"ignore\")\n\n\npreprocessor = ColumnTransformer(transformers=[\n    (\"num_trans\", numeric_transformer, numeric_features),\n    (\"cat_trans\", categorical_transformer, categorical_features)\n])\n\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.ensemble import RandomForestClassifier\n\npipeline = Pipeline(steps=[\n    (\"preproc\", preprocessor),\n    (\"model\", LogisticRegression())\n])\n\n\nfrom sklearn import set_config\nset_config(display='diagram')\npipeline\n\nPipeline(steps=[('preproc',\n                 ColumnTransformer(transformers=[('num_trans',\n                                                  Pipeline(steps=[('imputer',\n                                                                   SimpleImputer()),\n                                                                  ('scaler',\n                                                                   StandardScaler())]),\n                                                  ['math score',\n                                                   'reading score',\n                                                   'writing score']),\n                                                 ('cat_trans',\n                                                  OneHotEncoder(handle_unknown='ignore'),\n                                                  ['sex', 'race/ethnicity',\n                                                   'parental level of '\n                                                   'education',\n                                                   'lunch',\n                                                   'test preparation '\n                                                   'course'])])),\n                ('model', LogisticRegression())])In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.PipelinePipeline(steps=[('preproc',\n                 ColumnTransformer(transformers=[('num_trans',\n                                                  Pipeline(steps=[('imputer',\n                                                                   SimpleImputer()),\n                                                                  ('scaler',\n                                                                   StandardScaler())]),\n                                                  ['math score',\n                                                   'reading score',\n                                                   'writing score']),\n                                                 ('cat_trans',\n                                                  OneHotEncoder(handle_unknown='ignore'),\n                                                  ['sex', 'race/ethnicity',\n                                                   'parental level of '\n                                                   'education',\n                                                   'lunch',\n                                                   'test preparation '\n                                                   'course'])])),\n                ('model', LogisticRegression())])preproc: ColumnTransformerColumnTransformer(transformers=[('num_trans',\n                                 Pipeline(steps=[('imputer', SimpleImputer()),\n                                                 ('scaler', StandardScaler())]),\n                                 ['math score', 'reading score',\n                                  'writing score']),\n                                ('cat_trans',\n                                 OneHotEncoder(handle_unknown='ignore'),\n                                 ['sex', 'race/ethnicity',\n                                  'parental level of education', 'lunch',\n                                  'test preparation course'])])num_trans['math score', 'reading score', 'writing score']SimpleImputerSimpleImputer()StandardScalerStandardScaler()cat_trans['sex', 'race/ethnicity', 'parental level of education', 'lunch', 'test preparation course']OneHotEncoderOneHotEncoder(handle_unknown='ignore')LogisticRegressionLogisticRegression()\n\n\n\nPAMIETAJ - obiekt pipeline to obiekt pythonowy i tak jak obiekt modelu można go zapisać do pickla.\n\n\nfrom sklearn.model_selection import train_test_split\nX_tr, X_test, y_tr, y_test = train_test_split(X,y,\ntest_size=0.2, random_state=42)\n\npipeline.fit(X_tr, y_tr)\n\nscore = pipeline.score(X_test, y_test)\nprint(score)\n\n0.45\n\n\n\nimport joblib\njoblib.dump(pipeline, 'your_pipeline.pkl')\n\n['your_pipeline.pkl']\n\n\nTU ZACZYNA SIĘ MAGIA OBIEKTOWEGO PYTHONA - nie pisz kodu i nie uruchamiaj kodów wiele razy dla różnych parametrów - niech Python zrobi to za Ciebie\n\nparam_grid = [\n              {\"preproc__num_trans__imputer__strategy\":\n              [\"mean\",\"median\"],\n               \"model__n_estimators\":[2,5,10,100,500],\n               \"model__min_samples_leaf\": [1, 0.1],\n               \"model\":[RandomForestClassifier()]},\n              {\"preproc__num_trans__imputer__strategy\":\n                [\"mean\",\"median\"],\n               \"model__C\":[0.1,1.0,10.0,100.0,1000],\n                \"model\":[LogisticRegression()]}\n]\n\nfrom sklearn.model_selection import GridSearchCV\n\n\ngrid_search = GridSearchCV(pipeline, param_grid,\ncv=2, verbose=1, n_jobs=-1)\n\n\ngrid_search.fit(X_tr, y_tr)\n\ngrid_search.best_params_\n\nFitting 2 folds for each of 30 candidates, totalling 60 fits\n\n\n{'model': RandomForestClassifier(min_samples_leaf=0.1, n_estimators=2),\n 'model__min_samples_leaf': 0.1,\n 'model__n_estimators': 2,\n 'preproc__num_trans__imputer__strategy': 'mean'}\n\n\n\ngrid_search.score(X_test, y_test), grid_search.score(X_tr, y_tr)\n\n(0.45, 0.569620253164557)\n\n\nTeraz drobna modyfikacja - wiemy, że takiej zmiennej nie chcemy do modelu - ma tylko jedną wartość. Ale jak zweryfikować jakie to zmienne jeśli masz 3 mln kolumn?\n\ndf['bad_feature'] = 1\n\n\nX = df.drop(columns=['target'])\ny = df['target']\nX_tr, X_test, y_tr, y_test = train_test_split(X,y,\ntest_size=0.2, random_state=42)\n\n\nnumeric_features = ['math score','reading score','writing score', 'bad_feature']\n# znajdz sposób na automatyczny podział dla zmiennych numerycznych i nienumerycznych\n\n\ngrid_search = GridSearchCV(pipeline, param_grid,\ncv=2, verbose=1, n_jobs=-1)\n\ngrid_search.fit(X_tr, y_tr)\n\ngrid_search.best_params_\n\nFitting 2 folds for each of 30 candidates, totalling 60 fits\n\n\n{'model': RandomForestClassifier(n_estimators=2),\n 'model__min_samples_leaf': 1,\n 'model__n_estimators': 2,\n 'preproc__num_trans__imputer__strategy': 'mean'}\n\n\n\ngrid_search.score(X_tr, y_tr), grid_search.score(X_test, y_test)\n\n(0.8734177215189873, 0.45)\n\n\n\nNAPISZ WŁASNĄ KLASĘ KTÓRA ZREALIZUJE TRNSFORMACJE ZA CIEBIE\n\n# your own transformator class\n\nfrom sklearn.base import BaseEstimator, TransformerMixin\n\nclass DelOneValueFeature(BaseEstimator, TransformerMixin):\n    \"\"\"Description\"\"\"\n    def __init__(self):\n        self.one_value_features = []\n        \n    def fit(self, X, y=None):\n        for feature in X.columns:\n            unique = X[feature].unique()\n            if len(unique)==1:\n                self.one_value_features.append(feature)\n        return self\n    def transform(self, X, y=None):\n        if not self.one_value_features:\n            return X\n        return X.drop(axis='columns', columns=self.one_value_features)\n\n\n# UTWÓRZ NOWY PIPELINE\npipeline2 = Pipeline([\n    (\"moja_transformacja\",DelOneValueFeature()),\n    (\"preprocesser\", preprocessor),\n    (\"classifier\", LogisticRegression())])\n    \npipeline2.fit(X_tr, y_tr)\nscore2 = pipeline2.score(X_test, y_test)\n\nI JUZ :)\nA teraz zobacz jak prosta klasa potrafi ułatwić życie w modelach sieci neuronowej\n\n# przykład danych nieustrukturyzowanych \n\nimport tensorflow as tf\n\n\nclass myCallback(tf.keras.callbacks.Callback):\n    def on_epoch_end(self, epoch, logs={}):\n        if logs.get('accuracy') &gt; 0.95:\n            print(\"\\n osiągnięto 95% - zakończ trenowanie\")\n            self.model.stop_training = True\n\n\ncallbacks = myCallback()\nmnist = tf.keras.datasets.fashion_mnist\n\n\n(tr_im, tr_lab),(te_im, te_lab) = mnist.load_data()\ntr_im = tr_im/255\nte_im = te_im/255\n\nmodel = tf.keras.models.Sequential([\n    tf.keras.layers.Flatten(),\n    tf.keras.layers.Dense(128, activation=tf.nn.relu),\n    tf.keras.layers.Dense(10, activation=tf.nn.softmax)\n])\n\n\nmodel.compile(optimizer=\"adam\", loss=\"sparse_categorical_crossentropy\", metrics=['accuracy'])\n\n\nmodel.fit(tr_im, tr_lab, epochs=40, callbacks=[callbacks])\n\nEpoch 1/40\n1875/1875 [==============================] - 3s 2ms/step - loss: 0.4943 - accuracy: 0.8260\nEpoch 2/40\n1875/1875 [==============================] - 3s 2ms/step - loss: 0.3734 - accuracy: 0.8651\nEpoch 3/40\n1875/1875 [==============================] - 3s 2ms/step - loss: 0.3371 - accuracy: 0.8765\nEpoch 4/40\n1875/1875 [==============================] - 3s 2ms/step - loss: 0.3115 - accuracy: 0.8851\nEpoch 5/40\n1875/1875 [==============================] - 3s 2ms/step - loss: 0.2950 - accuracy: 0.8916\nEpoch 6/40\n1875/1875 [==============================] - 3s 2ms/step - loss: 0.2792 - accuracy: 0.8969\nEpoch 7/40\n1875/1875 [==============================] - 3s 2ms/step - loss: 0.2687 - accuracy: 0.8995\nEpoch 8/40\n1875/1875 [==============================] - 3s 2ms/step - loss: 0.2562 - accuracy: 0.9045\nEpoch 9/40\n1875/1875 [==============================] - 3s 2ms/step - loss: 0.2480 - accuracy: 0.9070\nEpoch 10/40\n1875/1875 [==============================] - 3s 2ms/step - loss: 0.2378 - accuracy: 0.9112\nEpoch 11/40\n1875/1875 [==============================] - 3s 2ms/step - loss: 0.2281 - accuracy: 0.9157\nEpoch 12/40\n1875/1875 [==============================] - 3s 2ms/step - loss: 0.2222 - accuracy: 0.9168\nEpoch 13/40\n1875/1875 [==============================] - 3s 2ms/step - loss: 0.2157 - accuracy: 0.9189\nEpoch 14/40\n1875/1875 [==============================] - 3s 2ms/step - loss: 0.2116 - accuracy: 0.9205\nEpoch 15/40\n1875/1875 [==============================] - 3s 2ms/step - loss: 0.2036 - accuracy: 0.9237\nEpoch 16/40\n1875/1875 [==============================] - 3s 2ms/step - loss: 0.1970 - accuracy: 0.9266\nEpoch 17/40\n1875/1875 [==============================] - 3s 2ms/step - loss: 0.1928 - accuracy: 0.9280\nEpoch 18/40\n1875/1875 [==============================] - 3s 2ms/step - loss: 0.1865 - accuracy: 0.9304\nEpoch 19/40\n1875/1875 [==============================] - 3s 2ms/step - loss: 0.1820 - accuracy: 0.9314\nEpoch 20/40\n1875/1875 [==============================] - 3s 2ms/step - loss: 0.1790 - accuracy: 0.9327\nEpoch 21/40\n1875/1875 [==============================] - 3s 2ms/step - loss: 0.1750 - accuracy: 0.9335\nEpoch 22/40\n1875/1875 [==============================] - 3s 2ms/step - loss: 0.1700 - accuracy: 0.9366\nEpoch 23/40\n1875/1875 [==============================] - 3s 2ms/step - loss: 0.1650 - accuracy: 0.9382\nEpoch 24/40\n1875/1875 [==============================] - 3s 2ms/step - loss: 0.1625 - accuracy: 0.9381\nEpoch 25/40\n1875/1875 [==============================] - 3s 2ms/step - loss: 0.1587 - accuracy: 0.9399\nEpoch 26/40\n1875/1875 [==============================] - 3s 2ms/step - loss: 0.1549 - accuracy: 0.9416\nEpoch 27/40\n1875/1875 [==============================] - 3s 2ms/step - loss: 0.1515 - accuracy: 0.9437\nEpoch 28/40\n1875/1875 [==============================] - 3s 2ms/step - loss: 0.1499 - accuracy: 0.9447\nEpoch 29/40\n1875/1875 [==============================] - 3s 2ms/step - loss: 0.1445 - accuracy: 0.9457\nEpoch 30/40\n1875/1875 [==============================] - 3s 2ms/step - loss: 0.1423 - accuracy: 0.9468\nEpoch 31/40\n1875/1875 [==============================] - 3s 2ms/step - loss: 0.1401 - accuracy: 0.9468\nEpoch 32/40\n1875/1875 [==============================] - 3s 2ms/step - loss: 0.1368 - accuracy: 0.9486\nEpoch 33/40\n1861/1875 [============================&gt;.] - ETA: 0s - loss: 0.1334 - accuracy: 0.9505\n osiągnięto 95% - zakończ trenowanie\n1875/1875 [==============================] - 3s 2ms/step - loss: 0.1333 - accuracy: 0.9506\n\n\n&lt;keras.src.callbacks.History at 0xfffe90eb8410&gt;",
    "crumbs": [
      "222890-D",
      "Ćwiczenia",
      "dane nieustruktyryzowane"
    ]
  },
  {
    "objectID": "wyklad1.html",
    "href": "wyklad1.html",
    "title": "Od plików płaskich do Data Mash",
    "section": "",
    "text": "Rozwój technologii informatycznych spowodował dostęp do niewyobrażalnych ilości nowego zasobu jakim są ustrukturyzowane jak i nieustrukturyzowane dane.\nDane przyczyniły się do powstania tysięcy nowych narzędzi do generowania, zbierania, przechowywania i przetwarzania informacji na niespotykaną dotąd skalę.\nZasób ten nie jest nowością i dostępny jest od bardzo dawna. Jednak dopiero po wprowadzeniu systemu pisma można było zacząć prowadzić zapis i przetwarzanie w postaci rachunkowości czy rejestrów różnych rzeczy takich jak: zaludnienie w krajach, spisy rzek, jezior, najgłębsze miejsca itp.\nPojawienie się nowych wyzwań naukowych i biznesowych staje się możliwe do realizacji dzięki budowie systemów opartych na otwartym oprogramowaniu, jak również dzięki wykorzystaniu klastrów komputerów do wspomagania przetwarzania ogromnych ilości danych.\nDziś systemy takie jak SAS, Apache Hadoop,Apache Kafka , Apache Spark, Apache Flink i ich chmurowe odpowiedniki, używane są na szeroką skalę w wielu instytucjach i firmach niemal w każdej dziedzinie. Narzędzia te wykorzystywane są w bankowości, opiece zdrowotnej, naukach przyrodniczych, produkcji, sektorze publicznym czy sprzedaży.\nEpoka danych stawia przed nami coraz to nowsze wyzwania związane nie tylko z ilością, ale i z czasem przetwarzania danych.\nNowe wyzwania biznesowe to między innymi:\n\ninteligentna reklama tysięcy produktów dla milionów klientów,\nprzetwarzanie danych o genach, RNA czy też białkach genus,\ninteligentne wykrywanie różnorodnych sposobów nadużyć wśród setek miliardów transakcji kart kredytowych,\nsymulacje giełdowe oparte o tysiące instrumentów finansowych\n…\n\n\n\nDane ustrukturyzowane zorganizowane są w kolumnach cech charakteryzujących każdą obserwację (wiersze). Kolumny posiadają etykietę, która wskazuje na ich interpretację.\nPrzykładem kolumn mogą być takie cechy jak: płeć, wzrost czy ilość kedytów, na podstawie których można przewidywać czy klient będzie spłacał kredyt czy też nie.\n\n\nCode\ndane_klientow = {\"sex\":[\"m\",\"f\",\"m\",\"m\",\"f\"],\n \"height\":[160, 172, 158, 174, 192],\n \"credits\":[0,0,1,3,1]\n }\n\ndf = pd.DataFrame(dane_klientow)\nprint(df)\n\n\n  sex  height  credits\n0   m     160        0\n1   f     172        0\n2   m     158        1\n3   m     174        3\n4   f     192        1\n\n\nTakie przewidywanie również oznaczane jest jako cecha (ang. target).\n\n\nCode\ndf['target'] = [0,1,1,0,0]\nprint(df)\n\n\n  sex  height  credits  target\n0   m     160        0       0\n1   f     172        0       1\n2   m     158        1       1\n3   m     174        3       0\n4   f     192        1       0\n\n\n\n\n\nW wielu językach programowania domyślnym pojemnikiem na przechowywanie wartości są zmienne.\nwiek = 47\nstan_cywilny = 'kawaler'\nNie są one jednak praktyczną formą do przechowywania i manipulowania danymi.\nJednym z rozwiązań jest przechowywanie wszystkich cech (np. klienta) w jednym obiekcie.\nW Pythonie zadanie to moze realizować obiekt listy, który pozwala przechowywać rózne typy danych w jednym obiekcie.\n\nklient = [38, 'kawaler', 1, 56.3]\nprint(f\"dane klienta {klient} w obiekcie: {type(klient)}\")\n\ndane klienta [38, 'kawaler', 1, 56.3] w obiekcie: &lt;class 'list'&gt;\n\n\nZ punktu widzenia przerwarzania i modelowania mozliwość ta wprowadza więcej problemów niz korzyści. Sprawdźmy domyślne operacje:\n\n\nCode\na = [1,2,3]\nb = [4,5,6]\nprint(f\"a={a}, b={b}\")\nprint(f\"a+b={a+b}\")\n\n\na=[1, 2, 3], b=[4, 5, 6]\na+b=[1, 2, 3, 4, 5, 6]\n\n\nnatomiast:\n\n\nCode\nprint(f\"a={a}, b={b}\")\nprint(f\"a*b\")\ntry:\n    print(f\"a*b= {a*b}\")\nexcept TypeError:\n    print(\"operacja niezdefiniowana\")\n\n\na=[1, 2, 3], b=[4, 5, 6]\na*b\noperacja niezdefiniowana\n\n\nBiblioteka Numpy:\n\nimport numpy as np\naa = np.array([1,2,3])\nbb = np.array([4,5,6])\n\nprint(type(aa))\n\n&lt;class 'numpy.ndarray'&gt;\n\n\n\n\nCode\nprint(f\"aa={aa}, bb={bb}\")\nprint(f\"aa+bb={aa+bb}\")\nprint(f\"aa*bb={aa*bb}\")\n\n\naa=[1 2 3], bb=[4 5 6]\naa+bb=[5 7 9]\naa*bb=[ 4 10 18]\n\n\nDzięki tak otrzymanym tabelom cech możemy stosować algorytmy tj. XGBoost lub regresji logistycznej w celu wyznaczenia odpowiedniej kombinacji zmiennych wpływających na prawdopodobieństwo dobrego albo i złego klienta.\nPodstawowe systemy bazodanowe związane z językiem SQL również realizują modele danych, w których dane ładnowane są do (ustrukturyzowanych) tabel. \nDane nieustrukturyzowane to takie, które nie są ułożone wtabelarycznej postaci.\n\n!Uwaga - nie oznacza to, iż dane nie możemy przetworzyć do jakiejś postaci tabelarzycznej.\n\nPrzykładem może być dźwięk, obrazczy tekst. Poszczególne litery, częstotliwości czy piksele nie niosą ze sobą żadnych informacji. Nie tworzą osobnych cech, co jest kluczowe dla odróżnienia ich od danych ustrukturyzowanych.\n\nZna typy danych ustrukturyzowanych jak i nieustrukturyzowanych (K2A_W02, K2A_W04, O2_W04, O2_W07)",
    "crumbs": [
      "222890-D",
      "Wykłady",
      "Od plików płaskich do Data Mash"
    ]
  },
  {
    "objectID": "wyklad1.html#dane",
    "href": "wyklad1.html#dane",
    "title": "Od plików płaskich do Data Mash",
    "section": "",
    "text": "Rozwój technologii informatycznych spowodował dostęp do niewyobrażalnych ilości nowego zasobu jakim są ustrukturyzowane jak i nieustrukturyzowane dane.\nDane przyczyniły się do powstania tysięcy nowych narzędzi do generowania, zbierania, przechowywania i przetwarzania informacji na niespotykaną dotąd skalę.\nZasób ten nie jest nowością i dostępny jest od bardzo dawna. Jednak dopiero po wprowadzeniu systemu pisma można było zacząć prowadzić zapis i przetwarzanie w postaci rachunkowości czy rejestrów różnych rzeczy takich jak: zaludnienie w krajach, spisy rzek, jezior, najgłębsze miejsca itp.\nPojawienie się nowych wyzwań naukowych i biznesowych staje się możliwe do realizacji dzięki budowie systemów opartych na otwartym oprogramowaniu, jak również dzięki wykorzystaniu klastrów komputerów do wspomagania przetwarzania ogromnych ilości danych.\nDziś systemy takie jak SAS, Apache Hadoop,Apache Kafka , Apache Spark, Apache Flink i ich chmurowe odpowiedniki, używane są na szeroką skalę w wielu instytucjach i firmach niemal w każdej dziedzinie. Narzędzia te wykorzystywane są w bankowości, opiece zdrowotnej, naukach przyrodniczych, produkcji, sektorze publicznym czy sprzedaży.\nEpoka danych stawia przed nami coraz to nowsze wyzwania związane nie tylko z ilością, ale i z czasem przetwarzania danych.\nNowe wyzwania biznesowe to między innymi:\n\ninteligentna reklama tysięcy produktów dla milionów klientów,\nprzetwarzanie danych o genach, RNA czy też białkach genus,\ninteligentne wykrywanie różnorodnych sposobów nadużyć wśród setek miliardów transakcji kart kredytowych,\nsymulacje giełdowe oparte o tysiące instrumentów finansowych\n…\n\n\n\nDane ustrukturyzowane zorganizowane są w kolumnach cech charakteryzujących każdą obserwację (wiersze). Kolumny posiadają etykietę, która wskazuje na ich interpretację.\nPrzykładem kolumn mogą być takie cechy jak: płeć, wzrost czy ilość kedytów, na podstawie których można przewidywać czy klient będzie spłacał kredyt czy też nie.\n\n\nCode\ndane_klientow = {\"sex\":[\"m\",\"f\",\"m\",\"m\",\"f\"],\n \"height\":[160, 172, 158, 174, 192],\n \"credits\":[0,0,1,3,1]\n }\n\ndf = pd.DataFrame(dane_klientow)\nprint(df)\n\n\n  sex  height  credits\n0   m     160        0\n1   f     172        0\n2   m     158        1\n3   m     174        3\n4   f     192        1\n\n\nTakie przewidywanie również oznaczane jest jako cecha (ang. target).\n\n\nCode\ndf['target'] = [0,1,1,0,0]\nprint(df)\n\n\n  sex  height  credits  target\n0   m     160        0       0\n1   f     172        0       1\n2   m     158        1       1\n3   m     174        3       0\n4   f     192        1       0\n\n\n\n\n\nW wielu językach programowania domyślnym pojemnikiem na przechowywanie wartości są zmienne.\nwiek = 47\nstan_cywilny = 'kawaler'\nNie są one jednak praktyczną formą do przechowywania i manipulowania danymi.\nJednym z rozwiązań jest przechowywanie wszystkich cech (np. klienta) w jednym obiekcie.\nW Pythonie zadanie to moze realizować obiekt listy, który pozwala przechowywać rózne typy danych w jednym obiekcie.\n\nklient = [38, 'kawaler', 1, 56.3]\nprint(f\"dane klienta {klient} w obiekcie: {type(klient)}\")\n\ndane klienta [38, 'kawaler', 1, 56.3] w obiekcie: &lt;class 'list'&gt;\n\n\nZ punktu widzenia przerwarzania i modelowania mozliwość ta wprowadza więcej problemów niz korzyści. Sprawdźmy domyślne operacje:\n\n\nCode\na = [1,2,3]\nb = [4,5,6]\nprint(f\"a={a}, b={b}\")\nprint(f\"a+b={a+b}\")\n\n\na=[1, 2, 3], b=[4, 5, 6]\na+b=[1, 2, 3, 4, 5, 6]\n\n\nnatomiast:\n\n\nCode\nprint(f\"a={a}, b={b}\")\nprint(f\"a*b\")\ntry:\n    print(f\"a*b= {a*b}\")\nexcept TypeError:\n    print(\"operacja niezdefiniowana\")\n\n\na=[1, 2, 3], b=[4, 5, 6]\na*b\noperacja niezdefiniowana\n\n\nBiblioteka Numpy:\n\nimport numpy as np\naa = np.array([1,2,3])\nbb = np.array([4,5,6])\n\nprint(type(aa))\n\n&lt;class 'numpy.ndarray'&gt;\n\n\n\n\nCode\nprint(f\"aa={aa}, bb={bb}\")\nprint(f\"aa+bb={aa+bb}\")\nprint(f\"aa*bb={aa*bb}\")\n\n\naa=[1 2 3], bb=[4 5 6]\naa+bb=[5 7 9]\naa*bb=[ 4 10 18]\n\n\nDzięki tak otrzymanym tabelom cech możemy stosować algorytmy tj. XGBoost lub regresji logistycznej w celu wyznaczenia odpowiedniej kombinacji zmiennych wpływających na prawdopodobieństwo dobrego albo i złego klienta.\nPodstawowe systemy bazodanowe związane z językiem SQL również realizują modele danych, w których dane ładnowane są do (ustrukturyzowanych) tabel. \nDane nieustrukturyzowane to takie, które nie są ułożone wtabelarycznej postaci.\n\n!Uwaga - nie oznacza to, iż dane nie możemy przetworzyć do jakiejś postaci tabelarzycznej.\n\nPrzykładem może być dźwięk, obrazczy tekst. Poszczególne litery, częstotliwości czy piksele nie niosą ze sobą żadnych informacji. Nie tworzą osobnych cech, co jest kluczowe dla odróżnienia ich od danych ustrukturyzowanych.\n\nZna typy danych ustrukturyzowanych jak i nieustrukturyzowanych (K2A_W02, K2A_W04, O2_W04, O2_W07)",
    "crumbs": [
      "222890-D",
      "Wykłady",
      "Od plików płaskich do Data Mash"
    ]
  },
  {
    "objectID": "wyklad1.html#źródła-danych",
    "href": "wyklad1.html#źródła-danych",
    "title": "Od plików płaskich do Data Mash",
    "section": "Źródła danych",
    "text": "Źródła danych\nDo trzech największych “generatorów” danych należą:\n\ndane społeczne w formie tekstów (tweety, wpisy w portalach społecznościowych, komentarze), zdjęć czy plików wideo. Przydatne do problemów biznesowych realizujących ocenę zachowań i nastrojów konsumentów w analizach marketingowych.\nIoT: dane pochodzące z czujników, czy też logi działania urządzeń i użytkowników (np. na stronie www).\ndane transakcyjne: czyli ogólnie to co w każdej chwili generowane jest jako transakcje pojawiające się zarówno w trybie online jak i w trybie offline.\n\n\nPythonowe źródła danych\n\n\nRzeczywisty proces generowania danych\nDane generowane są w postaci nieograniczonej - pojawiają się na skutek ciągłych działań systemów. W swoim telefonie wygenerowałeś dziś (a nawet na tych zajęciach!) wiele danych. Czy na następnych zajęciach lub tez jutro nie będziesz ich generował?\nDane zawsze generowane są jako jakaś forma strumienia danych.\nSystemy obsługujące strumienie danych: - hurtownie danych - systemy monitorujące działania urządzeń (IoT) - systemy transakcyjne - systemy analityczne stron www - reklamy on-line - media społecznościowe - systemy logowania - ….\n\nfirma to organizacja, która generuje i odpowiada na ciągły strumień danych. Zobacz\n\nW przetwarzaniu wsadowym źródłem (ale i wynikiem przetwarzania) danych jest plik. Jest on zapisywany raz i można się do niego odwołać (może na nim działać wiele procesów - zadań). Nazwa pliku to element identyfikujący zbiór rekordów.\nW przypadku strumienia zdarzenie jest generowane tylko raz przez tzw. producenta (zwanego też nadawcą lub dostawcą). Powstałe zdarzenie przetwarzane może być przez wielu tzw. konsumentów (odbiorców). Zdarzenia strumieniowe grupowane są w tzw. tematy (ang. topics).",
    "crumbs": [
      "222890-D",
      "Wykłady",
      "Od plików płaskich do Data Mash"
    ]
  },
  {
    "objectID": "wyklad1.html#big-data",
    "href": "wyklad1.html#big-data",
    "title": "Od plików płaskich do Data Mash",
    "section": "Big Data",
    "text": "Big Data\n\n,,Big Data is like teenage sex: everyone talks about it, nobody really knows how to do it, everyone thinks everyone else is doing it, so every one claims they are doing it.’’ — Dan Ariely, Professor of Psychology and Behavioral Economics, Duke University\n\n\none, two, … four V\n\nVolume (Objętość) - rozmiar danych produkowanych na całym świecie przyrasta w tempie wykładniczym.\nVelocity (Szybkość) - tempo produkowania danych, szybkości ich przesyłania i przetwarzania.\nVariety (Zróżnicowanie) - tradycyjne dane kojarzą się nam z postacią alfanumeryczną złożoną z liter i cyfr. Obecnie mamy do dyspozycji obrazy, dźwięki, pliki wideo, strumienie danych z IoT\nVeracity (Wiarygodność) - Czy dane są kompletne i poprawne? Czy obiektywnie odzwierciedlają rzeczywistość? Czy są podstawą do podejmowania decyzji?\nValue - The value that the data actually holds. In the end, it’s all about cost and benefits.\n\n\nCelem obliczeń nie są liczby, lecz ich zrozumienie R.W. Hamming 1962.",
    "crumbs": [
      "222890-D",
      "Wykłady",
      "Od plików płaskich do Data Mash"
    ]
  },
  {
    "objectID": "wyklad1.html#modele-przetwarzania-danych",
    "href": "wyklad1.html#modele-przetwarzania-danych",
    "title": "Od plików płaskich do Data Mash",
    "section": "Modele przetwarzania danych",
    "text": "Modele przetwarzania danych\nDane w biznesie przetwarzane są praktycznie od zawsze. W ciągu ostatnich dziesięcioleci ilość przetwarzanych danych systematycznie rośnie co wpływa na proces przygotowania i przetwarzania danych.\n\nTrochę historii\n\nLata 60-te : Kolekcje danych, bazy danych\nLata 70-te : Relacyjne modele danych i ich implementacja w systemach OLTP\n1975 : Pierwsze komputery osobiste\nLata 80-te : Zaawansowane modele danych, extended-relational, objective oriented, aplikacyjno-zorientowane itp.\n1983 : Początek internetu\nLata 90-te : Data mining, hurtownie danych, systemy OLAP\nPóźniej : NoSQL, Hadoop, SPARK, data lake\n2002 : AWS , 2005: Hadoop, Cloud computing\n\nWiększość danych przechowywana jest w bazach lub hurtowniach danych. Standardowo dostęp do danych sprowadza się najczęściej do realizacji zapytań poprzez aplikację.\nSposób wykorzystania i realizacji procesu dostępu do bazy danych nazywamy modelem przetwarzania. Najczęściej używane są dwie implementacje:\n\n\nModel Tradycyjny\nModel tradycyjny - przetwarzanie transakcyjne w trybie on-line, OLTP (on-line transaction processing). Świetnie sprawdza się w przypadku obsługi bieżącej np. obsługa klienta, rejestr zamówień, obsługa sprzedaży itp. Wykorzystywany w systemach Enterprise Resource Planning (ERP) Systems, Customer Relationship Management (CRM) software, and web-based applications.\n\nModel ten dostarcza efektywnych rozwiązań m.in do:\n\nefektywnego i bezpiecznego przechowywania danych,\ntransakcyjnego odtwarzanie danych po awarii,\noptymalizacji dostępu do danych,\nzarządzania współbieżnością,\nprzetwarzania zdarzeń -&gt; odczyt -&gt; zapis\n\nCo w przypadku gdy mamy do czynienia z:\n\nagregacjami danych z wielu systemów (np. dla wielu sklepów),\nraportowanie i podsumowania danych,\noptymalizacja złożonych zapytań,\nwspomaganie decyzji biznesowych.\n\nBadania nad tego typu zagadnieniami doprowadziły do sformułowania nowego modelu przetwarzania danych oraz nowego typu baz danych - Hurtownie Danych (Data warehouse).\n\n\nModel OLAP\nPrzetwarzanie analityczne on-line OLAP (on-line analytic processing).\nWspieranie procesów analizy i dostarczanie narzędzi umożliwiających analizę wielowymiarową (czas, miejsce, produkt).\nProces zrzucania danych z różnych systemów do jednej bazy nazywamy Extract-Transform-Load (ETL) (normalizacja i encoding and schema transaction).\nAnaliza danych z hurtowni to przede wszystkim obliczanie agregatów (podsumowań) dotyczących wymiarów hurtowni. Proces ten jest całkowicie sterowany przez użytkownika.\nPrzykład\nZałóżmy, że mamy dostęp do hurtowni danych gdzie przechowywane są informacje dotyczące sprzedaży produktów w supermarkecie. Jak przeanalizować zapytania:\n\nJaka jest łączna sprzedaż produktów w kolejnych kwartałach, miesiącach, tygodniach ?\nJaka jest sprzedaż produktów z podziałem na rodzaje produktów ?\nJaka jest sprzedaż produktów z podziałem na oddziały supermarketu ?\n\nOdpowiedzi na te pytania pozwalają określić wąskie gardła sprzedaży produktów przynoszących deficyt, zaplanować zapasy w magazynach czy porównać sprzedaż różnych grup w różnych oddziałach supermarketu.\nW ramach Hurtowni Danych najczęściej wykonuje się dwa rodzaje zapytań(oba w trybie batchowym): 1. Wykonywane okresowo w czasie zapytania raportowe obliczające biznesowe statystyki 2. Wykonywane ad-hoc zapytania wspomagające krytyczne decyzje biznesowe.\n\n\nWiedza:\n\nZna historię i filozofię modeli przetwarzania danych.\nZna typy danych ustrukturyzowanych jak i nieustrukturyzowanych\n\n\n\nUmiejętności:\n\nRozróżnia typy danych strukturyzowanych jak i niestrukturyzowanych\n\n\n\nKompetencje:\n\nUtrwala umiejętność samodzielnego uzupełniania wiedzy teoretycznej jak i praktycznej w zakresie programowania, modelowania, nowych technologii informatycznych z wykorzystaniem analizy w czasie rzeczywistym.",
    "crumbs": [
      "222890-D",
      "Wykłady",
      "Od plików płaskich do Data Mash"
    ]
  },
  {
    "objectID": "wyklad2.html",
    "href": "wyklad2.html",
    "title": "Analiza strumieni danych",
    "section": "",
    "text": "Oczekiwania vs Rzeczywistość\n\nKiedy podjąć decyzję biznesową ?\n\n\n\n\nBatch = Duże, historyczne zbiory\nStream = Strumień danych, on line, przesyłane w trybie ciągłym\n\n\n\n\n\nBatch = minuty, godziny, dni (patrz Hurtownie danych)\nStream = Real-time/near-real-time\n\n\n\n\n\nBatch = możliwe i stosowane bardzo czesto\nStream = ,,niemożliwe’’\n\n\n\n\n\nExtract, Transform, Load is a basic pattern for data processing, commonly known in data warehousing. It’s all about extracting data from a source, transforming the data (business rules) and at the end writing/loading everything to a target (Hadoop, Relational Database, Data Warehouse etc.)\n\n\n\nSystemy Big data mogą być częścią (źródłem) dla hurtowni danych (np. Data Lake, Enterprise Data Hub)\nAle Hurtownie danych nie są systemami Big Data!\n\nHurtownie danych\n\n\nprzetrzymywanie danych wysoko strukturyzowanych\nskupione na analizach i procesie raportowania\n100% accuracy\n\n\nBig Data\n\n\ndane o dowolnej strukturze\nsłuży do różnorodnych celów opartych na danych (analityka, data science …)\nponiżej 100% accuracy\n\n\n\n\n\nGdy mówimy o skali (nie o języku Scala), najczęściej przychodzi nam na myśl przeglądarka Google. Przeszukuje ona ogromne zbiory danychz dużą prędkością. Sama nazwa Goolge wskasuje na skalę (colowo przyjęto błędną nazwę w zapisie googol co oznacza 1 i 100 zer).\n\nSprawdź czy do końca zajęć uda Ci się zapisać liczbę googol na kartce.\n\nPowinno być dla Ciebie jasne, że żadne tradycyjne systemy, np relacyjne systemy baz danych, ani programowanie imperatywne nie są w stanie obłużyć przeszukiwania takiej ilości danych. Problemy te doprowadziły do budowy rozproszonych systemów plików Google File System, MapReduce (paradygmat programowania równoległego), czy Bigtable (skalowalna pamięć masowa ustrukturyzowanych danych znajdujących się na GFS).\n\n\nZnajdź prosty algorytm map reduce w dowolnym języku programowania i uruchom go.\n\n\nJak poprawić ?",
    "crumbs": [
      "222890-D",
      "Wykłady",
      "Analiza strumieni danych"
    ]
  },
  {
    "objectID": "wyklad2.html#batch-vs-stream-processing",
    "href": "wyklad2.html#batch-vs-stream-processing",
    "title": "Analiza strumieni danych",
    "section": "",
    "text": "Oczekiwania vs Rzeczywistość\n\nKiedy podjąć decyzję biznesową ?\n\n\n\n\nBatch = Duże, historyczne zbiory\nStream = Strumień danych, on line, przesyłane w trybie ciągłym\n\n\n\n\n\nBatch = minuty, godziny, dni (patrz Hurtownie danych)\nStream = Real-time/near-real-time\n\n\n\n\n\nBatch = możliwe i stosowane bardzo czesto\nStream = ,,niemożliwe’’\n\n\n\n\n\nExtract, Transform, Load is a basic pattern for data processing, commonly known in data warehousing. It’s all about extracting data from a source, transforming the data (business rules) and at the end writing/loading everything to a target (Hadoop, Relational Database, Data Warehouse etc.)\n\n\n\nSystemy Big data mogą być częścią (źródłem) dla hurtowni danych (np. Data Lake, Enterprise Data Hub)\nAle Hurtownie danych nie są systemami Big Data!\n\nHurtownie danych\n\n\nprzetrzymywanie danych wysoko strukturyzowanych\nskupione na analizach i procesie raportowania\n100% accuracy\n\n\nBig Data\n\n\ndane o dowolnej strukturze\nsłuży do różnorodnych celów opartych na danych (analityka, data science …)\nponiżej 100% accuracy\n\n\n\n\n\nGdy mówimy o skali (nie o języku Scala), najczęściej przychodzi nam na myśl przeglądarka Google. Przeszukuje ona ogromne zbiory danychz dużą prędkością. Sama nazwa Goolge wskasuje na skalę (colowo przyjęto błędną nazwę w zapisie googol co oznacza 1 i 100 zer).\n\nSprawdź czy do końca zajęć uda Ci się zapisać liczbę googol na kartce.\n\nPowinno być dla Ciebie jasne, że żadne tradycyjne systemy, np relacyjne systemy baz danych, ani programowanie imperatywne nie są w stanie obłużyć przeszukiwania takiej ilości danych. Problemy te doprowadziły do budowy rozproszonych systemów plików Google File System, MapReduce (paradygmat programowania równoległego), czy Bigtable (skalowalna pamięć masowa ustrukturyzowanych danych znajdujących się na GFS).\n\n\nZnajdź prosty algorytm map reduce w dowolnym języku programowania i uruchom go.\n\n\nJak poprawić ?",
    "crumbs": [
      "222890-D",
      "Wykłady",
      "Analiza strumieni danych"
    ]
  },
  {
    "objectID": "wyklad2.html#strumienie-danych",
    "href": "wyklad2.html#strumienie-danych",
    "title": "Analiza strumieni danych",
    "section": "Strumienie danych",
    "text": "Strumienie danych\nStrumieniowanie możesz kojarzyć z serwisów przesyłających video w trybie online. Gdy oglądasz swój ulubiony serial (tak jak teraz na zajęciach) serwis odpowiadający za strumieniowanie w nieprzerwany sposób przesyła do ciebie kolejne “porcje” video. Identycznie koncepcja ta realizowana jest w przypadku danych strumieniowych. Format przesyłanych porcji nie musi być plikiem video, wszystko zależy od celu realizowanego biznesowo. Np. ciągły pomiar z różnego rodzaju czujników w farbykach, elektrowniach itp. Warto odnotować, że masz do czynienia z ciągłym strumieniem danych, które przetwarzać musisz w czasie rzeczywistym. Nie możesz czekać do zatrzymania linii produkcyjnych w celu wykonania analizy, wszystkie pojawiające się problemy chcesz rejestrować natychmiast i jak najszybciej na nie reagować.\n\nAnaliza strumieni danych to ciągłe przetwarzanie i analiza dużych zbiorów danych w ruchu.\n\nPorównuj to do wsakazanych powyżej elementów Big Data. Przetwarzanie Batchowe jest przeciwieństwem do przetwarzania strumieniowego. Najpierw zbierasz duże ilości danych a potem realizujesz analizy. Możesz oczywiście zawsze pobrać video w całości zanim je obejrzysz, ale czy miałoby to sens? Istnieją przypadki gdy takie podejście nie stanowi problemu, ale już tu widzisz, że przetwarzanie strumieniowe może przynieść dla biznesu dodatkowe wartości dodane, których trudno oczekiwać przy wsadowym przetwarzaniu.\nciekawe informacje\n\nAnaliza danych w czasie rzeczywistym a przetwarzanie strumienia zdarzeń\nŁatwo jest połączyć analizę w czasie rzeczywistym i analizę strumieniową (lub przetwarzanie strumienia zdarzeń). Ale chociaż technologie analizy strumieniowej mogą umożliwiać analizę w czasie rzeczywistym, to nie to samo!\nAnaliza strumieniowa polega na przetwarzaniu danych w ruchu. Analityka w czasie rzeczywistym to dowolna metoda przetwarzania danych, która skutkuje okresem opóźnienia określanym jako „w czasie rzeczywistym”.\nZazwyczaj systemy analizy czasu rzeczywistego są definiowane jako twarde i miękkie systemy czasu rzeczywistego. Niedotrzymanie terminu w twardych systemach czasu rzeczywistego, takich jak samolot, jest katastrofalne, a w miękkich systemach czasu rzeczywistego, takich jak stacja pogodowa, niedotrzymanie terminów może prowadzić do bezużytecznych danych.\nPonadto, podczas gdy analiza strumieniowa implikuje istnienie architektury strumieniowej, analiza w czasie rzeczywistym nie implikuje żadnej konkretnej architektury.\nWszystko, co implikuje analityka w czasie rzeczywistym, polega na tym, że tworzenie i przetwarzanie danych odbywa się w dowolnym czasie, który firma definiuje jako „w czasie rzeczywistym”.\n\n\nŹródła danych przesyłanych strumieniowo obejmują:\n\nczujniki sprzętu,\nstrumienie kliknięć,\nśledzenie lokalizacji\ninterackcja z użytkownikiem: co robią użytkownicy Twojej witryny?\nkanały mediów społecznościowych,\nnotowania giełdowe,\naktywność w aplikacjach\ninne.\n\nFirmy wykorzystują analitykę strumieniową do odkrywania i interpretowania wzorców, tworzenia wizualizacji, przekazywania spostrzeżeń i alertów oraz uruchamiania procesów w czasie rzeczywistym lub zbliżonym do rzeczywistego.",
    "crumbs": [
      "222890-D",
      "Wykłady",
      "Analiza strumieni danych"
    ]
  },
  {
    "objectID": "wyklad2.html#uzasadnienie-biznesowe",
    "href": "wyklad2.html#uzasadnienie-biznesowe",
    "title": "Analiza strumieni danych",
    "section": "Uzasadnienie biznesowe",
    "text": "Uzasadnienie biznesowe\nAnalityka służy do znajdowania znaczących wzorców w danych i odkrywania nowej wiedzy. Dotyczy to zarówno transmisji strumieniowych, jak i tradycyjnych analiz.\nAle w dzisiejszym świecie natura „znajdowania sensownych wzorców w danych” uległa zmianie, ponieważ zmienił się charakter danych. Szybkość, objętość i rodzaje danych eksplodowały.\nTwitter produkuje ponad 500 milionów tweetów dziennie. IDC przewiduje, że do 2025 roku urządzenia Internetu rzeczy (IoT) będą w stanie wygenerować 79,4 zettabajtów (ZB) danych. I te trendy nie wykazują oznak spowolnienia.\nBiorąc pod uwagę nowy charakter danych, główną zaletą analizy strumieniowej jest to, że pomaga ona firmom znajdować znaczące wzorce w danych i odkrywać nową wiedzę ,,w czasie rzeczywistym” lub zbliżonym do rzeczywistego.\n\nktóry pojazd firmowej floty ma prawie pusty bak i gdzie wysłać prowadzącego pojazd do tankowania.\nKtóry pojazd floty zużywa najwięcej paliwa i dlaczego?\nKtóre urządzenia w zakładzie czy fabryce mogą ulec awarii w ciągu najbliższych dni?\nJakie części zamienne trzeba będzie wymienić i w których maszynach w najbliższym czasie ?\nIlu klientów aktualnie robi zakupy w sklepie i czy można im coś zaproponować ?\nCzy klient dzwoni w celu zerwania umowy ?\ni wiele wiele innych.\n\n\nPrzykładowe biznesowe zastosowania\n\nDane z sensorów IoT i detekcja anomalii\nStock Trading (problemy regresyjne) - czas reagowania na zmiany i czas zakupy i sprzedaży akcji.\nClickstream for websites (problem klasyfikacji) - śledzenie i analiza gości na stronie serwisu internetowego - personalizacja strony i treści.\n\n8 najlepszych przykładów analizy w czasie rzeczywistym\nBiznesowe zastosowania",
    "crumbs": [
      "222890-D",
      "Wykłady",
      "Analiza strumieni danych"
    ]
  },
  {
    "objectID": "wyklad2.html#definicje",
    "href": "wyklad2.html#definicje",
    "title": "Analiza strumieni danych",
    "section": "Definicje",
    "text": "Definicje\nZapoznaj się z tematem danych strumieniowych\n\nDefinicja 1 - Zdarzenie czyli wszystko co możemy zaobserwować w pewnej chwili czasu. Generowane są jako bezpośredni skutek działania.\nDefinicja 2 - W przypadku danych zdarzenie rozumiemy jako niezmienialny rekord w strumieniu danych zakodowany jako JSON, XML, CSV lub binarnie.\nDefinicja 3 - Ciągły strumień zdarzeń to nieskończony zbiór pojedynczych zdarzeń uporządkowanych w czasie np. logi z urządzenia.\nDefinicja 4 - Strumień danych to dane tworzone przyrostowo w czasie, generowane ze statycznych danych (baza danych, czytanie lini z pliku) bądź w sposób dynamiczny (logi, sensory, funkcje).\n\n\nPrzedsiębiorstwo to organizacja, która generuje i odpowiada na ciągły strumień zdarzeń.\n\nAnalityka strumieniowa (ang. stream analytics) nazywana jest również przetwarzaniem strumieniowym zdarzeń (ang. event stream processing) - przetwarzanie dużej ilości danych już na etapie ich generowania.\nNiezależnie od zastosowanej technologi wszystkie dane powstają jako ciągły strumień zdarzeń (działania użytkowników na stronie www, logi systemowe, pomiary z sensorów).",
    "crumbs": [
      "222890-D",
      "Wykłady",
      "Analiza strumieni danych"
    ]
  },
  {
    "objectID": "wyklad2.html#czas-w-analizie-danych-w-czasie-rzeczywistym",
    "href": "wyklad2.html#czas-w-analizie-danych-w-czasie-rzeczywistym",
    "title": "Analiza strumieni danych",
    "section": "Czas w analizie danych w czasie rzeczywistym",
    "text": "Czas w analizie danych w czasie rzeczywistym\nW przypadku przetwarzania wsadowego przetwarzamy dane historyczne i czas uruchomienia procesu przetwarzania nie ma nic wspólnego z czasem występowania analizowanych zdarzeń.\nDla danych strumieniowych mamy dwie koncepcje czasu:\n\nczas zdarzenia (event time) - czas w którym zdarzenie się wydarzyło.\nczas przetwarzania (processing time) - czas w którym system przetwarza zdarzenie.\n\nW przypadku idealnej sytuacji:\n\nW rzeczywistości przetwarzanie danych zawsze odbywa się z pewnym opóźnieniem, co reprezentowane jest przez punkty pojawiające się poniżej funkcji dla sytuacji idealnej (poniżej diagonalnej).\n\nW aplikacjach przetwarzania strumieniowego istotne okazują się różnice miedzy czasem powstania zdarzenia i jego procesowania. Do najczęstszych przyczyn opóźnienia wyszczególnia się przesyłanie danych przez sieć czy brak komunikacji między urządzeniem a siecią. Prostym przykładem jest tu przejazd samochodem przez tunel i śledzenie położenia przez aplikację GPS.\nMożesz oczywiście zliczać ilość takich pominiętych zdarzeń i uruchomić alarm w sytuacji gdy takich odrzutów będzie za dużo. Drugim (chyba częściej) wykorzystywanym sposobem jest zastosowanie korekty z wykorzystaniem tzw. watermarkingu.\nProces przetwarzania zdarzeń w czasie rzeczywistym można przedstawić w postaci funkcji schodkowej, reprezentowanej na rysunku: \nJak można zauważyć nie wszystkie zdarzenia wnoszą wkład do analizy i przetwarzania. Realizację procesu przetwarzania wraz z uwzględnieniem dodatkowego czasu na pojawienie się zdarzeń (watermark) można przedstawić jako proces obejmujący wszystkie zdarzenia powyżej przerywanej linii. Dodatkowy czas pozwolił na przetworzenie dodatkowych zdarzeń, natomiast nadal mogą zdarzyć się punkty, które nie będą brane pod uwagę.  \nPrzedstawione na wykresach sytuacje jawnie wskazują dlaczego pojęcie czasu jest istotnym czynnikiem i wymaga ścisłego określenia już na poziomie definiowania potrzeb biznesowych. Przypisywanie znaczników czasu do danych (zdarzeń) to trudne zadanie.",
    "crumbs": [
      "222890-D",
      "Wykłady",
      "Analiza strumieni danych"
    ]
  },
  {
    "objectID": "wyklad2.html#okna-czasowe",
    "href": "wyklad2.html#okna-czasowe",
    "title": "Analiza strumieni danych",
    "section": "okna czasowe",
    "text": "okna czasowe\nOkno rozłączne (ang. tumbling window) czyli okno o stałej długości. Jego cechą charakterystyczną jest to, iż każde zdarzenie należy tylko do jednego okna.  \nOkno przesuwne (ang. sliding window) obejmuje wszystkie zdarzenia następujące w określonej długości między sobą.  \nOkno skokowe (ang. hopping window) tak jak okno rozłączne ma stałą długość, ale pozwala się w nim na zachodzenie jednych okien na inne. Stosowane zazwyczaj do wygładzenia danych.",
    "crumbs": [
      "222890-D",
      "Wykłady",
      "Analiza strumieni danych"
    ]
  },
  {
    "objectID": "wyklad2.html#aplikacje-dla-strumieniowania-danych",
    "href": "wyklad2.html#aplikacje-dla-strumieniowania-danych",
    "title": "Analiza strumieni danych",
    "section": "Aplikacje dla strumieniowania danych",
    "text": "Aplikacje dla strumieniowania danych\nAplikacja przetwarzająca strumień zdarzeń powinna umożliwiać przetworzenie i zapisanie zdarzenia oraz dostęp (w tym samym czasie) do innych danych tak by móc dane zdarzenie przetworzyć (wykonać na nim dowolne przeliczenie) i zapisać jako stan lokalny. Stan ten może być zapisywany w wielu miejscach np. zmienne w programie, pliki lokalne, wew i zew bazy danych. Jedną z najbardziej znanych aplikacji tego typu jest Apache Kafka, którą można łączyć np. z Apache Spark bądź Apache Flink.\nPorównanie z aplikacją w trybie batch\n\nWiedza:\n\nZna możliwości i obszary zastosowania procesowania danych w czasie rzeczywistym\nRozumie potrzeby biznesowe podejmowania decyzji w bardzo krótkim czasie\n\n\n\nUmiejętności:\n\nRozumie ograniczenia wynikające z czasu przetwarzania przez urządzenia oraz systemy informatyczne\n\n\n\nKompetencje:\n\nUtrwala umiejętność samodzielnego uzupełniania wiedzy teoretycznej jak i praktycznej w zakresie programowania, modelowania, nowych technologii informatycznych z wykorzystaniem analizy w czasie rzeczywistym.\nFormułuje problem analityczny wraz z jego informatycznym rozwiązaniem",
    "crumbs": [
      "222890-D",
      "Wykłady",
      "Analiza strumieni danych"
    ]
  },
  {
    "objectID": "wyklad1S.html",
    "href": "wyklad1S.html",
    "title": "Wykład 1",
    "section": "",
    "text": "Rozwój technologii informatycznych spowodował dostęp do niewyobrażalnych ilości nowego zasobu jakim są ustrukturyzowane jak i nieustrukturyzowane dane.\n\nDane przyczyniły się do powstania tysięcy nowych narzędzi do generowania, zbierania, przechowywania i przetwarzania informacji na niespotykaną dotąd skalę.\nZasób ten nie jest nowością i dostępny jest od bardzo dawna. Jednak dopiero po wprowadzeniu systemu pisma można było zacząć prowadzić zapis i przetwarzanie w postaci rachunkowości czy rejestrów różnych rzeczy takich jak: zaludnienie w krajach, spisy rzek, jezior, najgłębsze miejsca itp.\nPojawienie się nowych wyzwań naukowych czy biznesowych staje się możliwe do realizacji dzięki budowie systemów opartych na otwartym oprogramowaniu, jak również dzięki wykorzystaniu domowych komputerów do wspomagania przetwarzania ogromnych ilości danych.\nDziś systemy takie jak SAS, Apache Hadoop, Apache Spark, Apache Flink dzięki rozwiązaniom chmurowym używane są na szeroką skalę w wielu instytucjach i firmach niemal w każdej dziedzinie. Narzędzia te wykorzystywane są w bankowości, opiece zdrowotnej, naukach przyrodniczych, produkcji, sektorze publicznym czy sprzedaży.\nEpoka danych stawia przed nami coraz to nowsze wyzwania związane nie tylko z ilością, ale i z czasem przetwarzania danych.\nNowe wyzwania biznesowe to między innymi:\n\ninteligentna reklama tysięcy produktów dla milionów klientów,\nprzetwarzanie danych o genach, RNA czy też białkach genus,\ninteligentne wykrywanie różnorodnych sposobów nadużyć wśród setek miliardów transakcji kart kredytowych,\nsymulacje giełdowe oparte o tysiące instrumentów finansowych\n…\n\nWszystkie algorytmy uczenia maszynowego wymagają danych ustrukturyzowanych zapisanych w tabelarycznej postaci (tensory).\nZorganizowane są one w kolumnach cech charakteryzujących każdą obserwację (wiersze). Przykładem mogą być takie cechy jak: płeć, wzrost czy ilość posiadanych samochodów, na podstawie których można przewidywać czy klient będzie spłacał kredyt czy też nie. Takie przewidywanie również oznaczane jest jako cecha. Zmienne te dobierane są tak, by łatwo można je było pozyskać. Dzięki tak otrzymanym tabelom cech możemy stosować algorytmy tj. XGBoost lub regresji logistycznej w celu wyznaczenia odpowiedniej kombinacji zmiennych wpływających na prawdopodobieństwo dobrego albo i złego klienta.\nPodstawowe systemy bazodanowe związane z językiem SQL również realizują modele danych, w których dane ładnowane są do (ustrukturyzowanych) tabel.\nDane nieustrukturyzowane to takie, które nie są ułożone w~tabelarycznej postaci. &gt; !Uwaga - nie oznacza to, iż dane nie możemy przetworzyć do jakiejś postaci tabelarzycnzej.\nPrzykładem może być dźwięk, obrazczy tekst. Poszczególne litery, częstotliwości~czy piksele nie niosą ze sobą żadnych informacji. Nie tworzą osobnych cech, co jest kluczowe dla odróżnienia ich od danych ustrukturyzowanych.\n\nZna typy danych ustrukturyzowanych jak i nieustrukturyzowanych (K2A_W02, K2A_W04, O2_W04, O2_W07)"
  },
  {
    "objectID": "wyklad1S.html#od-plikow-płaskich-do-data-lake",
    "href": "wyklad1S.html#od-plikow-płaskich-do-data-lake",
    "title": "Wykład 1",
    "section": "",
    "text": "Rozwój technologii informatycznych spowodował dostęp do niewyobrażalnych ilości nowego zasobu jakim są ustrukturyzowane jak i nieustrukturyzowane dane.\n\nDane przyczyniły się do powstania tysięcy nowych narzędzi do generowania, zbierania, przechowywania i przetwarzania informacji na niespotykaną dotąd skalę.\nZasób ten nie jest nowością i dostępny jest od bardzo dawna. Jednak dopiero po wprowadzeniu systemu pisma można było zacząć prowadzić zapis i przetwarzanie w postaci rachunkowości czy rejestrów różnych rzeczy takich jak: zaludnienie w krajach, spisy rzek, jezior, najgłębsze miejsca itp.\nPojawienie się nowych wyzwań naukowych czy biznesowych staje się możliwe do realizacji dzięki budowie systemów opartych na otwartym oprogramowaniu, jak również dzięki wykorzystaniu domowych komputerów do wspomagania przetwarzania ogromnych ilości danych.\nDziś systemy takie jak SAS, Apache Hadoop, Apache Spark, Apache Flink dzięki rozwiązaniom chmurowym używane są na szeroką skalę w wielu instytucjach i firmach niemal w każdej dziedzinie. Narzędzia te wykorzystywane są w bankowości, opiece zdrowotnej, naukach przyrodniczych, produkcji, sektorze publicznym czy sprzedaży.\nEpoka danych stawia przed nami coraz to nowsze wyzwania związane nie tylko z ilością, ale i z czasem przetwarzania danych.\nNowe wyzwania biznesowe to między innymi:\n\ninteligentna reklama tysięcy produktów dla milionów klientów,\nprzetwarzanie danych o genach, RNA czy też białkach genus,\ninteligentne wykrywanie różnorodnych sposobów nadużyć wśród setek miliardów transakcji kart kredytowych,\nsymulacje giełdowe oparte o tysiące instrumentów finansowych\n…\n\nWszystkie algorytmy uczenia maszynowego wymagają danych ustrukturyzowanych zapisanych w tabelarycznej postaci (tensory).\nZorganizowane są one w kolumnach cech charakteryzujących każdą obserwację (wiersze). Przykładem mogą być takie cechy jak: płeć, wzrost czy ilość posiadanych samochodów, na podstawie których można przewidywać czy klient będzie spłacał kredyt czy też nie. Takie przewidywanie również oznaczane jest jako cecha. Zmienne te dobierane są tak, by łatwo można je było pozyskać. Dzięki tak otrzymanym tabelom cech możemy stosować algorytmy tj. XGBoost lub regresji logistycznej w celu wyznaczenia odpowiedniej kombinacji zmiennych wpływających na prawdopodobieństwo dobrego albo i złego klienta.\nPodstawowe systemy bazodanowe związane z językiem SQL również realizują modele danych, w których dane ładnowane są do (ustrukturyzowanych) tabel.\nDane nieustrukturyzowane to takie, które nie są ułożone w~tabelarycznej postaci. &gt; !Uwaga - nie oznacza to, iż dane nie możemy przetworzyć do jakiejś postaci tabelarzycnzej.\nPrzykładem może być dźwięk, obrazczy tekst. Poszczególne litery, częstotliwości~czy piksele nie niosą ze sobą żadnych informacji. Nie tworzą osobnych cech, co jest kluczowe dla odróżnienia ich od danych ustrukturyzowanych.\n\nZna typy danych ustrukturyzowanych jak i nieustrukturyzowanych (K2A_W02, K2A_W04, O2_W04, O2_W07)"
  },
  {
    "objectID": "wyklad1S.html#źródła-danych",
    "href": "wyklad1S.html#źródła-danych",
    "title": "Wykład 1",
    "section": "Źródła danych",
    "text": "Źródła danych\nDo trzech największych “generatorów” danych należą:\n\ndane społeczne w formie tekstów (tweety, wpisy w~portalach społecznościowych, komentarze), zdjęć czy plików wideo. Przydatne do problemów biznesowych realizujących ocenę zachowań i nastrojów konsumentów w analizach marketingowych.\nIoT: dane pochodzące z czujników, czy też logi działania urządzeń i użytkowników (np. na stronie www).\nDane transakcyjne: czyli ogólnie to co w każdej chwili generowane jest jako transakcje pojawiające się zarówno w trybie online jak i w trybie offline.\n\n\nRzeczywisty proces generowania danych\nDane generowane są w postaci nieograniczonej - pojawiają się na skutek ciągłych działań systemów. W swoim telefonie wygenerowałeś dziś (a nawet na tych zajęciach!) wiele danych. Czy na następnych zajęciach lub tez jutro nie będziesz ich generował?\nDane zawsze generowane są jako jakaś forma strumienia danych.\nSystemy obsługujące strumienie danych: - hurtownie danych - systemy monitorujące działania urządzeń (IoT) - systemy transakcyjne - systemy analityczne stron www - reklamy on-line - media społecznościowe - systemy logowania - ….\n\nfirma to organizacja, która generuje i odpowiada na ciągły strumień danych. Zobacz\n\nW przetwarzaniu wsadowym źródłem (ale i wynikiem przetwarzania) danych jest plik. Jest on zapisywany raz i można się do niego odwołać (może na nim działać wiele procesów - zadań). Nazwa pliku to element identyfikujący zbiór rekordów.\nW przypadku strumienia zdarzenie jest generowane tylko raz przez tzw. producenta (zwanego też nadawcą lub dostawcą). Powstałe zdarzenie przetwarzane może być przez wielu tzw. konsumentów (odbiorców). Zdarzenia strumieniowe grupowane są w tzw. tematy (ang. topics)."
  },
  {
    "objectID": "wyklad1S.html#big-data",
    "href": "wyklad1S.html#big-data",
    "title": "Wykład 1",
    "section": "Big Data",
    "text": "Big Data\n\n,,Big Data is like teenage sex: everyone talks about it, nobody really knows how to do it, everyone thinks everyone else is doing it, so every one claims they are doing it.’’ — Dan Ariely, Professor of Psychology and Behavioral Economics, Duke University\n\n\none, two, … four V\n\nVolume (Objętość) - rozmiar danych produkowanych na całym świecie przyrasta w tempie wykładniczym.\nVelocity (Szybkość) - tempo produkowania danych, szybkości ich przesyłania i przetwarzania.\nVariety (Zróżnicowanie) - tradycyjne dane kojarzą się nam z postacią alfanumeryczną złożoną z liter i cyfr. Obecnie mamy do dyspozycji obrazy, dźwięki, pliki wideo, strumienie danych z IoT\nVeracity (Wiarygodność) - Czy dane są kompletne i poprawne? Czy obiektywnie odzwierciedlają rzeczywistość? Czy są podstawą do podejmowania decyzji?\nValue - The value that the data actually holds. In the end, it’s all about cost and benefits.\n\n\nCelem obliczeń nie są liczby, lecz ich zrozumienie R.W. Hamming 1962."
  },
  {
    "objectID": "wyklad1S.html#modele-przetwarzania-danych",
    "href": "wyklad1S.html#modele-przetwarzania-danych",
    "title": "Wykład 1",
    "section": "Modele przetwarzania danych",
    "text": "Modele przetwarzania danych\nDane w biznesie przetwarzane są praktycznie od zawsze. W ciągu ostatnich dziesięcioleci ilość przetwarzanych danych systematycznie rośnie co wpływa na proces przygotowania i przetwarzania danych.\n\nTrochę historii\n\nLata 60-te : Kolekcje danych, bazy danych\nLata 70-te : Relacyjne modele danych i ich implementacja w systemach OLTP\n1975 : Pierwsze komputery osobiste\nLata 80-te : Zaawansowane modele danych, extended-relational, objective oriented, aplikacyjno-zorientowane itp.\n1983 : Początek internetu\nLata 90-te : Data mining, hurtownie danych, systemy OLAP\nPóźniej : NoSQL, Hadoop, SPARK, data lake\n2002 : AWS , 2005: Hadoop, Cloud computing\n\nWiększość danych przechowywana jest w bazach lub hurtowniach danych. Standardowo dostęp do danych sprowadza się najczęściej do realizacji zapytań poprzez aplikację.\nSposób wykorzystania i realizacji procesu dostępu do bazy danych nazywamy modelem przetwarzania. Najczęściej używane są dwie implementacje:\n\n\nModel Tradycyjny\nModel tradycyjny - przetwarzanie transakcyjne w trybie on-line, OLTP (on-line transaction processing). Świetnie sprawdza się w przypadku obsługi bieżącej np. obsługa klienta, rejestr zamówień, obsługa sprzedaży itp. Wykorzystywany w systemach Enterprise Resource Planning (ERP) Systems, Customer Relationship Management (CRM) software, and web-based applications.\n\nModel ten dostarcza efektywnych rozwiązań m.in do:\n\nefektywnego i bezpiecznego przechowywania danych,\ntransakcyjnego odtwarzanie danych po awarii,\noptymalizacji dostępu do danych,\nzarządzania współbieżnością,\nprzetwarzania zdarzeń -&gt; odczyt -&gt; zapis\n\nCo w przypadku gdy mamy do czynienia z:\n\nagregacjami danych z wielu systemów (np. dla wielu sklepów),\nraportowanie i podsumowania danych,\noptymalizacja złożonych zapytań,\nwspomaganie decyzji biznesowych.\n\nBadania nad tego typu zagadnieniami doprowadziły do sformułowania nowego modelu przetwarzania danych oraz nowego typu baz danych - Hurtownie Danych (Data warehouse).\n\n\nModel OLAP\nPrzetwarzanie analityczne on-line OLAP (on-line analytic processing).\nWspieranie procesów analizy i dostarczanie narzędzi umożliwiających analizę wielowymiarową (czas, miejsce, produkt).\nProces zrzucania danych z różnych systemów do jednej bazy nazywamy Extract-Transform-Load (ETL) (normalizacja i encoding and schema transaction).\nAnaliza danych z hurtowni to przede wszystkim obliczanie agregatów (podsumowań) dotyczących wymiarów hurtowni. Proces ten jest całkowicie sterowany przez użytkownika.\nPrzykład\nZałóżmy, że mamy dostęp do hurtowni danych gdzie przechowywane są informacje dotyczące sprzedaży produktów w supermarkecie. Jak przeanalizować zapytania:\n\nJaka jest łączna sprzedaż produktów w kolejnych kwartałach, miesiącach, tygodniach ?\nJaka jest sprzedaż produktów z podziałem na rodzaje produktów ?\nJaka jest sprzedaż produktów z podziałem na oddziały supermarketu ?\n\nOdpowiedzi na te pytania pozwalają określić wąskie gardła sprzedaży produktów przynoszących deficyt, zaplanować zapasy w magazynach czy porównać sprzedaż różnych grup w różnych oddziałach supermarketu.\nW ramach Hurtowni Danych najczęściej wykonuje się dwa rodzaje zapytań(oba w trybie batchowym): 1. Wykonywane okresowo w czasie zapytania raportowe obliczające biznesowe statystyki 2. Wykonywane ad-hoc zapytania wspomagające krytyczne decyzje biznesowe."
  },
  {
    "objectID": "wyklad1S.html#źródła-danych-przesyłanych-strumieniowo-obejmują",
    "href": "wyklad1S.html#źródła-danych-przesyłanych-strumieniowo-obejmują",
    "title": "Wykład 1",
    "section": "Źródła danych przesyłanych strumieniowo obejmują:",
    "text": "Źródła danych przesyłanych strumieniowo obejmują:\n\nczujniki sprzętu,\nstrumienie kliknięć,\nśledzenie lokalizacji\ninterackcja z użytkownikiem: co robią użytkownicy Twojej witryny?\nkanały mediów społecznościowych,\nnotowania giełdowe,\naktywność w aplikacjach\ninne.\n\nFirmy wykorzystują analitykę strumieniową do odkrywania i interpretowania wzorców, tworzenia wizualizacji, przekazywania spostrzeżeń i alertów oraz uruchamiania procesów w czasie rzeczywistym lub zbliżonym do rzeczywistego.\n\nAnaliza danych w czasie rzeczywistym a przetwarzanie strumienia zdarzeń\nŁatwo jest połączyć analizę w czasie rzeczywistym i analizę strumieniową (lub przetwarzanie strumienia zdarzeń). Ale chociaż technologie analizy strumieniowej mogą umożliwiać analizę w czasie rzeczywistym, to nie to samo!\nAnaliza strumieniowa polega na przetwarzaniu danych w ruchu. Analityka w czasie rzeczywistym to dowolna metoda przetwarzania danych, która skutkuje okresem opóźnienia określanym jako „w czasie rzeczywistym”.\nZazwyczaj systemy analizy czasu rzeczywistego są definiowane jako twarde i miękkie systemy czasu rzeczywistego. Niedotrzymanie terminu w twardych systemach czasu rzeczywistego, takich jak samolot, jest katastrofalne, a w miękkich systemach czasu rzeczywistego, takich jak stacja pogodowa, niedotrzymanie terminów może prowadzić do bezużytecznych danych.\nPonadto, podczas gdy analiza strumieniowa implikuje istnienie architektury strumieniowej, analiza w czasie rzeczywistym nie implikuje żadnej konkretnej architektury.\nWszystko, co implikuje analityka w czasie rzeczywistym, polega na tym, że tworzenie i przetwarzanie danych odbywa się w dowolnym czasie, który firma definiuje jako „w czasie rzeczywistym”."
  },
  {
    "objectID": "wyklad1S.html#uzasadnienie-biznesowe",
    "href": "wyklad1S.html#uzasadnienie-biznesowe",
    "title": "Wykład 1",
    "section": "Uzasadnienie biznesowe",
    "text": "Uzasadnienie biznesowe\nAnalityka służy do znajdowania znaczących wzorców w danych i odkrywania nowej wiedzy. Dotyczy to zarówno transmisji strumieniowych, jak i tradycyjnych analiz.\nAle w dzisiejszym świecie natura „znajdowania sensownych wzorców w danych” uległa zmianie, ponieważ zmienił się charakter danych. Szybkość, objętość i rodzaje danych eksplodowały.\nTwitter produkuje ponad 500 milionów tweetów dziennie. IDC przewiduje, że do 2025 roku urządzenia Internetu rzeczy (IoT) będą w stanie wygenerować 79,4 zettabajtów (ZB) danych. I te trendy nie wykazują oznak spowolnienia.\nBiorąc pod uwagę nowy charakter danych, główną zaletą analizy strumieniowej jest to, że pomaga ona firmom znajdować znaczące wzorce w danych i odkrywać nową wiedzę ,,w czasie rzeczywistym” lub zbliżonym do rzeczywistego.\n\nktóry pojazd firmowej floty ma prawie pusty bak i~gdzie wysłać prowadzącego pojazd do tankowania.\nKtóry pojazd floty zużywa najwięcej paliwa i~dlaczego?\nKtóre urządzenia w~zakładzie czy fabryce mogą ulec awarii w~ciągu najbliższych dni?\nJakie części zamienne trzeba będzie wymienić iwktórych maszynach w~najbliższym czasie ?\nIlu klientów aktualnie robi zakupy w~sklepie i~czy można im coś zaproponować ?\nCzy klient dzwoni w~celu zerwania umowy ?\ni wiele wiele innych.\n\n8 najlepszych przykładów\nBiznesowe zastosowania"
  },
  {
    "objectID": "wyklad1S.html#definicje",
    "href": "wyklad1S.html#definicje",
    "title": "Wykład 1",
    "section": "Definicje",
    "text": "Definicje\nZapoznaj się z tematem danych strumieniowych\n\nDefinicja 1 - Zdarzenie czyli wszystko co możemy zaobserwować w pewnej chwili czasu. Definicja 2 - W przypadku danych zdarzenie rozumiemy jako niezmienialny rekord w strumieniu danych zakodowany jako JSON, XML, CSV lub binarnie. Definicja 3 - Ciągły strumień zdarzeń to nieskończony zbiór pojedynczych zdarzeń uporządkowanych w czasie np. logi z urządzenia.\n\n\nPrzedsiębiorstwo to organizacja, która generuje i odpowiada na ciągły strumień zdarzeń.\n\n\nDefinicja 4 - Strumień danych to dane tworzone przyrostowo w czasie, generowane ze statycznych danych (baza danych, czytanie lini z pliku) bądź w sposób dynamiczny (logi, sensory, funkcje).\n\nAnalityka strumieniowa (ang. stream analytics) nazywana jest również przetwarzaniem strumieniowym zdarzen (ang. event stream processing) - przetwarzanie dużej ilości danych już na etapie ich generowania.\nGenerowane są jako bezpośredni skutek działania.\nNiezależnie od zastosowanej technologi wszystkie dane powstają jako ciągły strumień zdarzeń (działania użytkowników na stronie www, logi systemowe, pomiary z sensorów)."
  },
  {
    "objectID": "wyklad1S.html#aplikacje-dla-strumieniowania-danych",
    "href": "wyklad1S.html#aplikacje-dla-strumieniowania-danych",
    "title": "Wykład 1",
    "section": "Aplikacje dla strumieniowania danych",
    "text": "Aplikacje dla strumieniowania danych\nAplikacja przetwarzająca strumień zdarzeń powinna umożliwiać przetworzenie i zapisanie zdarzenia oraz dostęp (w tym samym czasie) do innych danych tak by móc dane zdarzenie przetworzyć (wykonać na nim dowolne przeliczenie) i zapisać jako stan lokalny. Stan ten może być zapisywany w wielu miejscach np. zmienne w programie, pliki lokalne, wew i zew bazy danych. Jedną z najbardziej znanych aplikacji tego typu jest Apache Kafka, którą można łączyć np. z Apache Spark bądź Apache Flink.\nPorównanie z aplikacją w trybie batch"
  },
  {
    "objectID": "ksiazki.html",
    "href": "ksiazki.html",
    "title": "Książki i strony WWW",
    "section": "",
    "text": "G. Maas, F. Garillot Stream Processing with Apache Spark Zobacz opis lub Kup e-book\nF. Hueske, V. Kalavri Stream Processing with Apache Flink Zobacz opis lub Kup e-book\nA. Bellemare Mikrousługi oparte na zdarzeniach. Wykorzystanie danych w organizacji na dużą skalę Zobacz opis lub Kup ksiązkę\n\n\n\n\n\nA. Geron Uczenie maszynowe z użyciem Scikit-Learn i TensorFlow. Wydanie III. Zobacz opis, Kup książkę lub Kup e-book.\nSebastian Raschka, Vahid Mirjalili Python. Machine learning i deep learning. Biblioteki scikit-learni TensorFlow 2. Wydanie III. Zobacz opis lub Kup książkę.\nW. McKinney Python w analizie danych. Przetwarzanie danych za pomocą pakietów Pandas i NumPy oraz środowiska Jupyter. Wydanie III Zobacz opis, Kup książkę lub Kup e-book\nD. McIlwraith, H. Marmanis, D. Babenko Inteligentna sieć. Algorytmy przyszłości. Wydanie II (ebook) Zobacz opis lub Kup książkę, Kup e-book\nJoel Grus Data science od podstaw. Analiza danych w Pythonie. Wydanie II. Zobacz opis lub Kup książkę, Kup e-book.\nJohn W. Foreman Mistrz analizy danych. Od danych do wiedzy. Zobacz opis lub Kup książkę, Kup e-book.\nAlberto Boschetti, Luca Massaron Python. Podstawy nauki o danych. Zobacz opis lub Kup książkę.\nR. Schutt, C. O’Neil Badanie danych. Raport z pierwszej lini działań. Zobacz opis lub Kup książkę.\nT. Segaran Nowe usługi 2.0. Przewodnik po analizie zbiorów danych Zobacz opis lub Kup książkę, Kup e-book\n\n\n\n\n\nF. Chollet Deep Learning. Praca z językiem Python i biblioteką Keras. Zobacz opis lub Kup książkę, Kup e-book\nJ. Patterson, A. Gibson Deep Learning. Praktyczne wprowadzenie (ebook) Zobacz opis lub Kup e-book\nV. Zocca, G. Spacagna, D. Slater, P. Roelants. Deep Learning. Uczenie głębokie z językiem Python. Sztuczna inteligencja i sieci neuronowe Zobacz opis lub Kup ebook\nD. Osinga Deep Learning. Receptury Zobacz opis lub Kup książkę, Kup e-book\nS. Weidman Uczenie głębokie od zera. Podstawy implementacji w Pythonie Zobacz opis lub Kup książkę, Kup e-book\nD. Foster Deep learning i modelowanie generatywne. Jak nauczyć komputer malowania, pisania, komponowania i grania Zobacz opis lub Kup książkę, Kup e-book\nJ. Howard, S. Gugger Deep learning dla programistów. Budowanie aplikacji AI za pomocą fastai i PyTorch Zobacz opis lub Kup książkę, Kup e-book\n\n\n\n\n\nJ. S. Damji, B. Wenig, T. Das, D. Lee Spark. Błyskawiczna analiza danych Zobacz opis lub Kup\nAkash Tandon, Sandy Ryza, Uri Laserson, Sean Owen, Josh Wills, Zaawansowana analiza danych w PySpark Zobacz opis Kup ksiązkę lub Kup e-book\nB. Chambers, M. Zaharia Spark: The Definitive Guide. Big Data Processing Made Simple (ebook) Zobacz opis lub Kup e-book\n\n\n\n\n\nG. Coldwind Zrozumieć programowanie Zobacz opis lub Kup książkę, Kup e-book\nA. Allain C++. Przewodnik dla początkujących Zobacz opis lub Kup książkę, Kup e-book\nS. Dasgupta, C. Papadimitriou, U. Vazirani Algorytmy PWN.\n\n\n\n\n\nJ. Krochmalski Docker. Projektowanie i wdrażanie aplikacji Zobacz opis lub Kup książkę, Kup e-book\nR. McKendrick, S. Gallagher Docker. Programowanie aplikacji dla zaawansowanych. Wydanie II Zobacz opis lub Kup książkę, Kup e-book\n\n\n\n\n\nP. Bell, B. Beer GitHub. Przyjazny przewodnik (ebook) Zobacz opis lub Kup e-book\n\n\n\n\n\nC. Althoff, Programista Samouk. Profesjonalny przewodnik do samodzielnej nauki kodowania. Zobacz opis lub Kup teraz, Kup e-book\nA. Sweigart, Automatyzacja nudnych zadań z pythonem. Zobacz opis lub Kup książkę, Kup e-book\nK. Reitz, T. Schlusser Przewodnik po Pythonie. Dobre praktyki i praktyczne narzędzia. Zobacz opis lub Kup teraz, Kup e-book\n\n\n\n\n\nB.Tate, L. Carslon, C. Hiibs, Ruby on Rails. Wprowadzenie. Wydanie II Zobacz opis lub Kup e-book\nB. Frain, Responsive Web Design. Projektowanie elastycznych witryn w HTML5 i CSS3, Zobacz opis lub Kup e-book\nK. Beck, TDD. Sztuda tworzenia, Zobacz opis lub Kup teraz, Kup e-book\nB. Dayley, Node.js, MongoDB, AngularJS. Kompendium wiedzy, Zobacz opis lub Kup teraz, Kup e-book\n\n\n\n\n\nA. Jacquier, O. Kondratyev, Quantum Machine Learning and Optimisation in Finance. On the Road to Quantum Advantage."
  },
  {
    "objectID": "ksiazki.html#książki",
    "href": "ksiazki.html#książki",
    "title": "Książki i strony WWW",
    "section": "",
    "text": "G. Maas, F. Garillot Stream Processing with Apache Spark Zobacz opis lub Kup e-book\nF. Hueske, V. Kalavri Stream Processing with Apache Flink Zobacz opis lub Kup e-book\nA. Bellemare Mikrousługi oparte na zdarzeniach. Wykorzystanie danych w organizacji na dużą skalę Zobacz opis lub Kup ksiązkę\n\n\n\n\n\nA. Geron Uczenie maszynowe z użyciem Scikit-Learn i TensorFlow. Wydanie III. Zobacz opis, Kup książkę lub Kup e-book.\nSebastian Raschka, Vahid Mirjalili Python. Machine learning i deep learning. Biblioteki scikit-learni TensorFlow 2. Wydanie III. Zobacz opis lub Kup książkę.\nW. McKinney Python w analizie danych. Przetwarzanie danych za pomocą pakietów Pandas i NumPy oraz środowiska Jupyter. Wydanie III Zobacz opis, Kup książkę lub Kup e-book\nD. McIlwraith, H. Marmanis, D. Babenko Inteligentna sieć. Algorytmy przyszłości. Wydanie II (ebook) Zobacz opis lub Kup książkę, Kup e-book\nJoel Grus Data science od podstaw. Analiza danych w Pythonie. Wydanie II. Zobacz opis lub Kup książkę, Kup e-book.\nJohn W. Foreman Mistrz analizy danych. Od danych do wiedzy. Zobacz opis lub Kup książkę, Kup e-book.\nAlberto Boschetti, Luca Massaron Python. Podstawy nauki o danych. Zobacz opis lub Kup książkę.\nR. Schutt, C. O’Neil Badanie danych. Raport z pierwszej lini działań. Zobacz opis lub Kup książkę.\nT. Segaran Nowe usługi 2.0. Przewodnik po analizie zbiorów danych Zobacz opis lub Kup książkę, Kup e-book\n\n\n\n\n\nF. Chollet Deep Learning. Praca z językiem Python i biblioteką Keras. Zobacz opis lub Kup książkę, Kup e-book\nJ. Patterson, A. Gibson Deep Learning. Praktyczne wprowadzenie (ebook) Zobacz opis lub Kup e-book\nV. Zocca, G. Spacagna, D. Slater, P. Roelants. Deep Learning. Uczenie głębokie z językiem Python. Sztuczna inteligencja i sieci neuronowe Zobacz opis lub Kup ebook\nD. Osinga Deep Learning. Receptury Zobacz opis lub Kup książkę, Kup e-book\nS. Weidman Uczenie głębokie od zera. Podstawy implementacji w Pythonie Zobacz opis lub Kup książkę, Kup e-book\nD. Foster Deep learning i modelowanie generatywne. Jak nauczyć komputer malowania, pisania, komponowania i grania Zobacz opis lub Kup książkę, Kup e-book\nJ. Howard, S. Gugger Deep learning dla programistów. Budowanie aplikacji AI za pomocą fastai i PyTorch Zobacz opis lub Kup książkę, Kup e-book\n\n\n\n\n\nJ. S. Damji, B. Wenig, T. Das, D. Lee Spark. Błyskawiczna analiza danych Zobacz opis lub Kup\nAkash Tandon, Sandy Ryza, Uri Laserson, Sean Owen, Josh Wills, Zaawansowana analiza danych w PySpark Zobacz opis Kup ksiązkę lub Kup e-book\nB. Chambers, M. Zaharia Spark: The Definitive Guide. Big Data Processing Made Simple (ebook) Zobacz opis lub Kup e-book\n\n\n\n\n\nG. Coldwind Zrozumieć programowanie Zobacz opis lub Kup książkę, Kup e-book\nA. Allain C++. Przewodnik dla początkujących Zobacz opis lub Kup książkę, Kup e-book\nS. Dasgupta, C. Papadimitriou, U. Vazirani Algorytmy PWN.\n\n\n\n\n\nJ. Krochmalski Docker. Projektowanie i wdrażanie aplikacji Zobacz opis lub Kup książkę, Kup e-book\nR. McKendrick, S. Gallagher Docker. Programowanie aplikacji dla zaawansowanych. Wydanie II Zobacz opis lub Kup książkę, Kup e-book\n\n\n\n\n\nP. Bell, B. Beer GitHub. Przyjazny przewodnik (ebook) Zobacz opis lub Kup e-book\n\n\n\n\n\nC. Althoff, Programista Samouk. Profesjonalny przewodnik do samodzielnej nauki kodowania. Zobacz opis lub Kup teraz, Kup e-book\nA. Sweigart, Automatyzacja nudnych zadań z pythonem. Zobacz opis lub Kup książkę, Kup e-book\nK. Reitz, T. Schlusser Przewodnik po Pythonie. Dobre praktyki i praktyczne narzędzia. Zobacz opis lub Kup teraz, Kup e-book\n\n\n\n\n\nB.Tate, L. Carslon, C. Hiibs, Ruby on Rails. Wprowadzenie. Wydanie II Zobacz opis lub Kup e-book\nB. Frain, Responsive Web Design. Projektowanie elastycznych witryn w HTML5 i CSS3, Zobacz opis lub Kup e-book\nK. Beck, TDD. Sztuda tworzenia, Zobacz opis lub Kup teraz, Kup e-book\nB. Dayley, Node.js, MongoDB, AngularJS. Kompendium wiedzy, Zobacz opis lub Kup teraz, Kup e-book\n\n\n\n\n\nA. Jacquier, O. Kondratyev, Quantum Machine Learning and Optimisation in Finance. On the Road to Quantum Advantage."
  },
  {
    "objectID": "ksiazki.html#strony-www",
    "href": "ksiazki.html#strony-www",
    "title": "Książki i strony WWW",
    "section": "Strony WWW",
    "text": "Strony WWW\n\nSoftware\n\nGithub\nGit-instrukcja\nwww.python.org\nPyPI python libraries\nAnaconda\nDocker\n\n\n\nPakiety python dla analiz danych\n\nNumPy\nSciPy\nPandas\nScikit-learn\nJupyter\nMatplotlib\nBeautiful Soup\nTheano\nKeras\nTensorFlow\nVirtual ENV\n\n\n\nEdytory tekstu\n\nNotepad++\nSublime Text\nVisual Studio Code\n\n\n\nMarkdown\n\nMD\n\n\n\nJupyter notebook\n\nGaleria ciekawych notatników\nIntro\nKernels\nBringing the best out of jupyter for data science\nJupyter extensions\nI don’t like notebooks\nJupyter lab\nSpeed up jupyter notebook\n\n\n\nPrzetwarzanie danych\n\ndata cookbook\n\n\n\nZbiory danych\n\nInternet Archive\nReddit\nKDnuggets\nKaggle\nList of datasets for machine learning research\nUCI Machine Learning Repo\nPublic API\nGoogle Datatset Search\n\n\n\nPython\n\nChris Albon Technical Notes on Using Data Science & AI\n40+ Python Statistics For Data Science Resources\nPractical Business Python\n\n\n\nkursy ML\n\nKurs Machine Learning - Andrew Ng, Stanford\nKurs Machine Learning - Andrew Ng, Stanford\nPython programming for data science"
  },
  {
    "objectID": "sylabus.html",
    "href": "sylabus.html",
    "title": "Syllabus",
    "section": "",
    "text": "Nazwa przedmiotu: Analiza danych w czasie rzeczywistym\nJednostka: SGH w Warszawie\nKod przedmiotu: 222890-D, 222890-S\nPunkty ECTS: 3\nJęzyk prowadzenia: polski\nPoziom przedmiotu: średnio-zaawansowany\nProwadzący: Sebastian Zając, sebastian.zajac@sgh.waw.pl\nWebsite: https://sebkaz-teaching.github.io/RTA_2023/"
  },
  {
    "objectID": "sylabus.html#cel-przedmiotu",
    "href": "sylabus.html#cel-przedmiotu",
    "title": "Syllabus",
    "section": "Cel Przedmiotu",
    "text": "Cel Przedmiotu\nPodejmowanie prawidłowych decyzji opartych na danych i ich analizie jest niezwykle istotne w dzisiejszym i nowoczesnym biznesie. Wprowadzenie nowoczesnych metod takich jak uczenie maszynowe, sztuczna inteligencja i głębokie sieci neuronowe, może znacznie poprawić zarówno zrozumienie biznesu, jak i jakość podejmowanych decyzji. Ponadto, szybkośc podejmowania decyzji jest kluczowym czynnikiem w dynamicznym środowisku biznesowym, zwłaszcza tam, gdzie pracuje się bezpośrednio z klientem. Zajęcia mają na celu przekazanie studentom doświadczenia oraz kompleksowej wiedzy teoretycznej w zakresie przetwarzania i analizy danych w czasie rzeczywistym oraz zaprezentowanie najnowszych technologii informatycznych służących do przetwarzania danych ustrukturyzowanych (pochodzących np. z hurtowni danych) jak i nieustrukturyzowanych (np. obrazy, dźwięk, strumieniowanie video) w trybie on-line. W toku zajęć przedstawiona zostanie filozofia analizy dużych danych w czasie rzeczywistym jz wykorzystaniem programowania w języku Python. Przedstawione zostaną struktury oprogramowania służące do przetwarzania danych wraz z omówieniem problemów i trudności jakie spotyka się w realizacji modelowania w czasie rzeczywistym dla dużej ilości danych. Wiedza teoretyczna zdobywana będzie (oprócz części wykładowej) poprzez realizację przypadków testowych w narzędziach takich jak Apache Spark czy Apache Kafka. Na zajęciach laboratoryjnych studenci korzystać będą z pełni skonfigurowanych środowisk programistycznych przygotowanych do przetwarzania, modelowania i analizy danych. Tak, aby oprócz umiejętności i znajomości technik analitycznych studenci poznali i zrozumieli najnowsze technologie informatyczne związane z przetwarzaniem danych w czasie rzeczywistym."
  },
  {
    "objectID": "sylabus.html#program-przedmiotu",
    "href": "sylabus.html#program-przedmiotu",
    "title": "Syllabus",
    "section": "Program przedmiotu",
    "text": "Program przedmiotu\n\nOd plików płaskich do Data Mash. Modele przetwarzania danych w Big Data.\nETL i modelowanie w trybie wsadowym (offline learning) i przyrostowym (online learning). Map-Reduce.\nStrumienie danych, zdarzenia i koncepcje czasu i okien czasowych w przetwarzaniu danych w czasie rzeczywistym.\nMikroserwisy i komunikacja przez REST API.\nWspółczesne architektury aplikacji do przetwarzania danych strumieniowych - Lambda, Kappa, Pub/Sub.\nPrzetwarzanie ustrukturyzowanych i niestrukturyzowanych danych. Środowisko programistyczne dla języka Python.\nWykorzystanie obiektowych elementów Pythona w procesie modelowania za pomocą Scikit-Learn i Keras\nPodstawy OOP dla języka Python. Budowa klasy dla algorytmu błądzenia losowego, Perceprtonu i Adeline.\nPrzygotowanie mikroserwisu z modelem ML do zastosowania produkcyjnego.\nStrumieniowanie danych z wykorzystaniem RDD dla Apache Spark. Wprowadzenie do obiektu DataFrame."
  },
  {
    "objectID": "sylabus.html#efekty-kształcenia",
    "href": "sylabus.html#efekty-kształcenia",
    "title": "Syllabus",
    "section": "Efekty kształcenia",
    "text": "Efekty kształcenia\n\nWiedza:\n\n\nZna historię i filozofię modeli przetwarzania danych Powiązania: (Analiza danych - Big Data)K2A_W01, (Analiza danych - Big Data)K2A_W03, (OGL)O2_W01, (OGL) O2_W02, (OGL)O2_W04, (OGL)O2_W07 Metody weryfikacji: kolokwium pisemne (pytania otwarte, zadania) Metody dokumentacji: wykaz pytań z kolokwium\nZna typy danych ustrukturyzowanych jak i nieustrukturyzowanych Powiązania: (Analiza danych - Big Data)K2A_W02, (Analiza danych - Big Data)K2A_W04, (OGL)O2_W04, (OGL) O2_W07 Metody weryfikacji: projekt Metody dokumentacji: prace pisemne studenta ( w trakcie semestru, zaliczeniowe, egzaminacyjne)\nZna możliwości i obszary zastosowania procesowania danych w czasie rzeczywistym Powiązania: (Analiza danych - Big Data)K2A_W01, (Analiza danych - Big Data)K2A_W02, (OGL)O2_W01, (OGL) O2_W04, (OGL)O2_W08 Metody weryfikacji: egzamin pisemny (pytania otwarte, zadania) Metody dokumentacji: wykaz pytań egzaminacyjnych\nZna teoretyczne aspekty struktury lambda i kappa Powiązania: (Analiza danych - Big Data)K2A_W03, (Analiza danych - Big Data)K2A_W05, (OGL)O2_W04, (OGL) O2_W06, (OGL)O2_W08 Metody weryfikacji: kolokwium pisemne (pytania otwarte, zadania) Metody dokumentacji: wykaz pytań z kolokwium\nUmie wybrać strukturę IT dla danego problemu biznesowego Powiązania: (Analiza danych - Big Data)K2A_W02, (Analiza danych - Big Data)K2A_W03, (OGL)O2_W01, (OGL) O2_W04, (OGL)O2_W06, (OGL)O2_W08 Metody weryfikacji: projekt Metody dokumentacji: prace pisemne studenta ( w trakcie semestru, zaliczeniowe, egzaminacyjne)\nRozumie potrzeby biznesowe podejmowania decyzji w bardzo krótkim czasie Powiązania: (Analiza danych - Big Data)K2A_W01, (Analiza danych - Big Data)K2A_W05, (OGL)O2_W01, (OGL) O2_W04, (OGL)O2_W06, (OGL)O2_W08 Metody weryfikacji: projekt Metody dokumentacji: prace pisemne studenta ( w trakcie semestru, zaliczeniowe, egzaminacyjne)\n\n\nUmiejętności:\n\n\nRozróżnia typy danych strukturyzowanych jak i niestrukturyzowanych Powiązania: K2A_U02, K2A_U07, K2A_U10, O2_U02 Metody weryfikacji: test Metody dokumentacji: prace pisemne studenta ( w trakcie semestru, zaliczeniowe, egzaminacyjne)\nUmie przygotować, przetwarzać oraz zachowywać dane generowane w czasie rzeczywistym Powiązania: K2A_U03, K2A_U05, K2A_U09, O2_U02, O2_U04 Metody weryfikacji: projekt Metody dokumentacji: prace pisemne studenta ( w trakcie semestru, zaliczeniowe, egzaminacyjne)\nRozumie ograniczenia wynikające z czasu przetwarzania przez urządzenia oraz systemy informatyczne Powiązania: K2A_U01, K2A_U07, K2A_U11, O2_U02 Metody weryfikacji: projekt Metody dokumentacji: prace pisemne studenta ( w trakcie semestru, zaliczeniowe, egzaminacyjne)\nUmie zastosować i skonstruować system do przetwarzania w czasie rzeczywistym Powiązania: K2A_U05, K2A_U10, O2_U05, O2_U06, O2_U07 Metody weryfikacji: projekt Metody dokumentacji: prace pisemne studenta ( w trakcie semestru, zaliczeniowe, egzaminacyjne)\nUmie przygotować raportowanie dla systemu przetwarzania w czasie rzeczywistym Powiązania: K2A_U02, K2A_U08, K2A_U10, O2_U06, O2_U07 Metody weryfikacji: projekt Metody dokumentacji: prace pisemne studenta ( w trakcie semestru, zaliczeniowe, egzaminacyjne)\n\n\nKompetencje:\n\n\nFormułuje problem analityczny wraz z jego informatycznym rozwiązaniem Powiązania: K2A_K01, K2A_K03, O2_K02, O2_K06, O2_K07 Metody weryfikacji: projekt, prezentacja Metody dokumentacji: prace pisemne studenta (w trakcie semestru, zaliczeniowe, egzaminacyjne)\nUtrwala umiejętność samodzielnego uzupełniania wiedzy teoretycznej jak i praktycznej w zakresie programowania, modelowania, nowych technologii informatycznych z wykorzystaniem analizy w czasie rzeczywistym. Powiązania: K2A_K02, K2A_K04, (OGL)O2_K01, (OGL) O2_K02, (OGL)O2_K05, (OGL)O2_K06 Metody weryfikacji: projekt Metody dokumentacji: prace pisemne studenta ( w trakcie semestru, zaliczeniowe, egzaminacyjne)"
  },
  {
    "objectID": "sylabus.html#realizacja-przedmiotu",
    "href": "sylabus.html#realizacja-przedmiotu",
    "title": "Syllabus",
    "section": "Realizacja przedmiotu",
    "text": "Realizacja przedmiotu\n\negzamin testowy 30%\nkolokwium 30%\nreferaty/eseje 40%\n\n## Literatura\n\nZając S. “Modelowanie dla biznesu. Analityka w czasie rzeczywistym - narzędzia informatyczne i biznesowe. Oficyna Wydawnicza SGH, Warszawa 2022\nK. Przanowski K. , Zając S. red. “Modelowanie dla biznesu, metody ML, modele portfela CF, modele rekurencyjne, analizy przeżycia, modele scoringowe, SGH, Warszawa 2020.\nFrątczak E., red. “Modelowanie dla biznesu, Regresja logistyczna, Regresja Poissona, Survival Data Mining, CRM, Credit Scoring”. SGH, Warszawa 2019.\nS. Raschka, Python. Uczenie maszynowe. Wydanie II\nMaas G., Garillot F. Stream Processing with Apache Spark, O’Reilly, 2021\nF. Hueske, V. Kalavri Stream Processing with Apache Flink, O’Reilly, 2021\nNandi A. “Spark for Python Developers”, 2015"
  },
  {
    "objectID": "sylabus.html#literatura-uzupełniająca",
    "href": "sylabus.html#literatura-uzupełniająca",
    "title": "Syllabus",
    "section": "Literatura uzupełniająca",
    "text": "Literatura uzupełniająca\n\nFrątczak E., “Statistics for Management & Economics” SGH, Warszawa, 2015\nSimon P., “Too Big to IGNORE. The Business Case for Big Data”, John Wiley & Sons Inc., 2013\nNandi A. “Spark for Python Developers”, 2015\nFrank J. Ohlhorst. “Big Data Analytics. Turning Big Data into Big Money”. John Wiley & Sons. Inc. 2013\nRussell J. “Zwinna analiza danych Apache Hadoop dla każdego”, Helion, 2014\nTodman C., “Projektowanie hurtowni danych, Wspomaganie zarządzania relacjami z klientami”, Helion, 2011"
  },
  {
    "objectID": "wyklad3.html",
    "href": "wyklad3.html",
    "title": "Mikroserwisy i komuniakcja przez REST API.",
    "section": "",
    "text": "Komunikacja sieciowa, relacyjne bazy danych, rozwiązania chmurowe i big data znacząco zmieniły sposób budowania systemów informatycznych i wykonywnia na niach pracy.\nPorównaj to jak “narzędzia” do realizacji przekazu (gazeta, radio, telewizja, internet, komunikatory, media społecznościowe) zmieniły interakcje międzyludzkie i struktury społeczne.\nKoncepcja mikrousługi (mikroserwisu) jest bardzo popularnym sposobem budowania systemów informatycznych jak i koncepcją przy tworzeniu oprogramowania czy realizacji firmy w duchu Data-Driven. Koncepcja ta pozwala zachować wydajność (rób jedną rzecz ale dobrze), elastyczność i jasną postać całej struktury.\nChociaż istnieją inne sposoby architektury projektów oprogramowania, „mikroserwisy” są często używane nie bez powodu. Idea mikroserwisów tkwi w nazwie: oprogramowanie jest reprezentowane jako wiele małych usług, które działają indywidualnie. Patrząc na ogólną architekturę, każda mikrousługa znajduje się w małej czarnej skrzynce z jasno zdefiniowanymi wejściami i wyjściami. Możesz porównać tego typu zachowanie do “czystej funkcji” w programowaniu funkcyjnym.\nW celu umożliwienia komunikacji różnych mikroserwisów często wybieranym rozwiązaniem jest wykorzystanie Application Programming Interfaces API .",
    "crumbs": [
      "222890-D",
      "Wykłady",
      "Mikroserwisy i komuniakcja przez REST API."
    ]
  },
  {
    "objectID": "wyklad3.html#komunikacja-przez-api",
    "href": "wyklad3.html#komunikacja-przez-api",
    "title": "Mikroserwisy i komuniakcja przez REST API.",
    "section": "Komunikacja przez API",
    "text": "Komunikacja przez API\nCentralnym elementem architektury mikrousług jest wykorzystanie interfejsów API. API to część, która pozwala na połączenie dwóch mikroserwisów. Interfejsy API są bardzo podobne do stron internetowych. Podobnie jak strona internetowa, serwer wysyła do Ciebie kod reprezentujący stronę internetową. Twoja przeglądarka internetowa interpretuje ten kod i wyświetla stronę internetową.\nWeźmy przypadek biznesowy z modelem ML jako usługą. Załóżmy, że pracujesz dla firmy sprzedającej mieszkania w Bostonie. Chcesz zwiększać sprzedaż i oferować naszym klientom lepszą jakość usług dzięki nowej aplikacji mobilnej, z której może korzystać nawet 1 000 000 osób jednocześnie. Możemy to osiągnąć, udostępniając prognozę wartości domu, gdy użytkownik prosi o wycenę przez Internet.\n\nCzym jest serwowanie modelu ML\n\nSzkolenie dobrego modelu ML to TYLKO pierwsza część całego procesu: Musisz udostępnić swój model użytkownikom końcowym. Robisz to, zapewniając dostęp do modelu na swoim serwerze.\nAby udostępnić model potrzebujesz: modelu, interpretera, danych wsadowych.\nWażne metryki\n\n\nczas oczekiwania,\nkoszty,\nliczba zapytać w jednostce czasu\n\n\nUdostępnianie danych między dwoma lub więcej systemami zawsze było podstawowym wymogiem tworzenia oprogramowania – DevOps vs. MLOps.\n\nGdy wywołasz interfejs API, otrzyma on Twoje żądanie. Żądanie wyzwala kod do uruchomienia na serwerze i generuje odpowiedź odesłaną do Ciebie. Jeśli coś pójdzie nie tak, możesz nie otrzymać żadnej odpowiedzi lub otrzymać kod błędu jako kod stanu HTTP.\n\nKlient-Serwer: Klient (system A) przesyła żądanie przez HTTP do adresu URL hostowanego przez system B, który zwraca odpowiedź. Identycznie działa np przeglądarka internetowa. Żądanie jest kierowane do serwera WWW, który zwraca tekstową stronę HTML.\n\n\nBezstanowe: Żądanie klienta powinno zawierać wszystkie informacje niezbędne do udzielenia pełnej odpowiedzi.\n\nInterfejsy API można wywoływać za pomocą wielu różnych narzędzi. Czasami możesz nawet użyć przeglądarki internetowej. Narzędzia takie jak CURL wykonują zadanie w wierszu poleceń. Możesz używać narzędzi, takich jak Postman, do wywoływania interfejsów API za pomocą interfejsu użytkownika.\n\nCała komunikacja jest objęta ustalonymi zasadami i praktykami, które są nazywane protokołem HTTP.\n\n\n\nZapytanie - Request\n\nAdres URL (np. http://mydomain:8000/getapi?&val1=43&val2=3) zawiera:\n- domenę, \n- port, \n- dodatkowe ścieżki, \n- zapytanie\nMetody HTTP:\n- GET, \n- POST\nNagłówki HTTP zawierają:\n- informacje o autoryzacji, \n- cookies metadata\n\nCała informacja zawarta jest w Content-Type: application/json, text … Accept: application/json, Authorization: Basic abase64string, Tokens 4. Ciało zapytania\nNajczęściej wybieranym formatem dla wymiany informacji między serwisami jest format JavaScript Object Notation (JSON). Przypomina on pythonowy obiekt słownika - “klucz”: “wartość”.\n{\n\"RAD\": 1,\n\"PTRATIO\": 15.3, \"INDUS\": 2.31, \"B\": 396.9,\n\"ZN\": 18,\n\"DIS\": 4.09, \"CRIM\": 0.00632, \"RM\": 6.575, \n\"AGE\": 65.2, \"CHAS\": 0, \"NOX\": 0.538, \n\"TAX\": 296, \"LSTAT\": 4.98\n}\n\n\nOdpowiedź - Response\n\nTreść odpowiedzi przekazywana jest razem z nagłówkiem oraz statusem:\n\n200 OK\nContent-Encoding: gzip\nContent-Type: text/html; charset=utf-8\nDate: Mon, 18 Jul 2016 16:06:00 GMT Server: Apache\nPath=/;\n\nnp.: “Content-Type” =&gt; ”application/json; charset=utf-8”, ”Server” =&gt; ”Genie/Julia/1.8.5”\nTreść (ciało) odpowiedzi:\n\n{\":input\":{\"RAD\":1,\"PTRATIO\":15.3,\"INDUS\":2.31,.....}}, {\":prediction\":[29.919737211857683]}\n\nHTTP status code:\n\n\n200 OK - prawidłowe wykonanie zapytania,\n40X Access Denied\n50X Internal server error\n\n\nWyszukaj informacje czym jest REST API.\n\n\nWiedza:\n\nZna możliwości i obszary zastosowania procesowania danych w czasie rzeczywistym\nUmie wybrać strukturę IT dla danego problemu biznesowego\nRozumie potrzeby biznesowe podejmowania decyzji w bardzo krótkim czasie\n\n\n\nUmiejętności:\n\nRozróżnia typy danych strukturyzowanych jak i niestrukturyzowanych\n\n\n\nKompetencje:\n\nUtrwala umiejętność samodzielnego uzupełniania wiedzy teoretycznej jak i praktycznej w zakresie programowania, modelowania, nowych technologii informatycznych z wykorzystaniem analizy w czasie rzeczywistym.",
    "crumbs": [
      "222890-D",
      "Wykłady",
      "Mikroserwisy i komuniakcja przez REST API."
    ]
  },
  {
    "objectID": "lab/cw2.html",
    "href": "lab/cw2.html",
    "title": "Producent Apache Kafka",
    "section": "",
    "text": "Tą wersję można przejść również posiadając nowy obraz dockerowy i uruchomiony docker desktop na własnym komputerze.\n\nPrzejdź do przeglądarki i uruchom stronę ze środowiskiem (w przypadku Docker uruchom localhost:8888).\nUruchom (w jupyter lab za pomocą ikony terminala) nowy terminal\nPrzejdź do katalogu głównego i wypisz listę wszystkich elementów. Sprawdź czy na liście znajduje się katalog kafka.\ncd ~\nls -all\nUruchom polecenie sprawdzające listę topiców serwera Kafki bash     kafka/bin/kafka-topics.sh --list --bootstrap-server broker:9092\nDodaj topic o nazwie streaming\nkafka/bin/kafka-topics.sh --bootstrap-server broker:9092 --create --topic streaming\nSprawdź listę tematów ponownie upewniając się, że posiadasz temat streaming\nUruchom nowy terminal na notatniku i utwórz producenta w konsoli generującego dane do nowego topicu\n\nkafka/bin/kafka-console-producer.sh --bootstrap-server broker:9092 --topic streaming\nAby sprawdzić czy wysyłanie wiadomości działa uruchom kolejne okno terminala i wpisz następującą komendę realizującą konsumenta w konsoli:\nkafka/bin/kafka-console-consumer.sh --bootstrap-server broker:9092 --topic streaming --from-beginning\n\nPamiętaj aby uruchamiać komendy z odpowiedniego katalogu.\n\n\n%%file stream.py\n\nimport json\nimport random\nimport sys\nfrom datetime import datetime, timedelta\nfrom time import sleep\n\nfrom kafka import KafkaProducer\n\nif __name__ == \"__main__\":\n    SERVER = \"broker:9092\"\n\n    producer = KafkaProducer(\n        bootstrap_servers=[SERVER],\n        value_serializer=lambda x: json.dumps(x).encode(\"utf-8\"),\n        api_version=(3, 7, 0),\n    )\n    \n    try:\n        while True:\n            \n            t = datetime.now() + timedelta(seconds=random.randint(-15, 0))\n            \n            message = {\n                \"time\" : str(t),\n                \"id\" : random.choice([\"a\", \"b\", \"c\", \"d\", \"e\"]),\n                \"values\" : random.randint(0,100)\n            }\n            \n            \n            producer.send(\"streaming\", value=message)\n            sleep(1)\n    except KeyboardInterrupt:\n        producer.close()",
    "crumbs": [
      "222890-D",
      "Ćwiczenia",
      "Producent Apache Kafka"
    ]
  },
  {
    "objectID": "lab/cw2.html#wersja-z-dostępem-do-środowiska",
    "href": "lab/cw2.html#wersja-z-dostępem-do-środowiska",
    "title": "Producent Apache Kafka",
    "section": "",
    "text": "Tą wersję można przejść również posiadając nowy obraz dockerowy i uruchomiony docker desktop na własnym komputerze.\n\nPrzejdź do przeglądarki i uruchom stronę ze środowiskiem (w przypadku Docker uruchom localhost:8888).\nUruchom (w jupyter lab za pomocą ikony terminala) nowy terminal\nPrzejdź do katalogu głównego i wypisz listę wszystkich elementów. Sprawdź czy na liście znajduje się katalog kafka.\ncd ~\nls -all\nUruchom polecenie sprawdzające listę topiców serwera Kafki bash     kafka/bin/kafka-topics.sh --list --bootstrap-server broker:9092\nDodaj topic o nazwie streaming\nkafka/bin/kafka-topics.sh --bootstrap-server broker:9092 --create --topic streaming\nSprawdź listę tematów ponownie upewniając się, że posiadasz temat streaming\nUruchom nowy terminal na notatniku i utwórz producenta w konsoli generującego dane do nowego topicu\n\nkafka/bin/kafka-console-producer.sh --bootstrap-server broker:9092 --topic streaming\nAby sprawdzić czy wysyłanie wiadomości działa uruchom kolejne okno terminala i wpisz następującą komendę realizującą konsumenta w konsoli:\nkafka/bin/kafka-console-consumer.sh --bootstrap-server broker:9092 --topic streaming --from-beginning\n\nPamiętaj aby uruchamiać komendy z odpowiedniego katalogu.\n\n\n%%file stream.py\n\nimport json\nimport random\nimport sys\nfrom datetime import datetime, timedelta\nfrom time import sleep\n\nfrom kafka import KafkaProducer\n\nif __name__ == \"__main__\":\n    SERVER = \"broker:9092\"\n\n    producer = KafkaProducer(\n        bootstrap_servers=[SERVER],\n        value_serializer=lambda x: json.dumps(x).encode(\"utf-8\"),\n        api_version=(3, 7, 0),\n    )\n    \n    try:\n        while True:\n            \n            t = datetime.now() + timedelta(seconds=random.randint(-15, 0))\n            \n            message = {\n                \"time\" : str(t),\n                \"id\" : random.choice([\"a\", \"b\", \"c\", \"d\", \"e\"]),\n                \"values\" : random.randint(0,100)\n            }\n            \n            \n            producer.send(\"streaming\", value=message)\n            sleep(1)\n    except KeyboardInterrupt:\n        producer.close()",
    "crumbs": [
      "222890-D",
      "Ćwiczenia",
      "Producent Apache Kafka"
    ]
  },
  {
    "objectID": "lab/cw2.html#wersja-obraz-docker",
    "href": "lab/cw2.html#wersja-obraz-docker",
    "title": "Producent Apache Kafka",
    "section": "Wersja obraz Docker",
    "text": "Wersja obraz Docker\n\nPrzejdź do katalogu jupyterlab i uruchom obraz poleceniem\ndocker compose up\nOtwórz nowy terminal i sprawdź listę topiców\ndocker exec broker kafka-topics --list --bootstrap-server broker:9092\nLista ta zazwyczaj jest pusta.\ndodaj topic o nazwie streaming\n\ndocker exec broker kafka-topics --bootstrap-server broker:9092 --create --topic streaming\n\nSprawdź listę tematów ponownie upewniając się, że posiadasz temat streaming\nUruchom nowy terminal na swoim komputerze i utwórz producenta generującego dane do nowego topicu\n\ndocker exec --interactive --tty broker kafka-console-producer --bootstrap-server broker:9092 --topic streaming\nAby sprawdzić czy wysyłanie wiadomości działa uruchom kolejne okno terminala i wpisz następującą komendę realizującą consumenta:\ndocker exec --interactive --tty broker kafka-console-consumer --bootstrap-server broker:9092 --topic streaming --from-beginning",
    "crumbs": [
      "222890-D",
      "Ćwiczenia",
      "Producent Apache Kafka"
    ]
  },
  {
    "objectID": "lab/cw3.html",
    "href": "lab/cw3.html",
    "title": "Dane ustrukturyzowane",
    "section": "",
    "text": "# Remove warnings\nimport warnings\nwarnings.filterwarnings('ignore')",
    "crumbs": [
      "222890-D",
      "Ćwiczenia",
      "Dane ustrukturyzowane"
    ]
  },
  {
    "objectID": "lab/cw3.html#dane-jako-zmienne",
    "href": "lab/cw3.html#dane-jako-zmienne",
    "title": "Dane ustrukturyzowane",
    "section": "Dane jako zmienne",
    "text": "Dane jako zmienne\n\n# variables\ncustomer1_age = 38\ncustomer1_height = 178\ncustomer1_loan = 34.23\ncustomer1_name = 'Zajac'\n\n\ndlaczego do analizy danych nie używamy zmiennych?\nNiezależnie od typu analizowanych i przetwarzanych danych w Pythonie możemy zebrać dane i reprezentować je jako pewna formy listy.\n\n\n# python lists\ncustomer = [38, 'Divorced', 1, 56.3, [\"\",\"\",\"\"], {}]\nprint(customer)\n\n\n# different types in one object\ntype(customer)\n\n\ndlaczego listy nie są najlepszym miejscem na przechowywanie danych?\n\nWeźmy dwie listy numeryczne\n\n# dwie listy danych\na = [1,2,3]\nb = [4,5,6]\n\nTypowe operacje na listach w analizach danych\n\n# dodawanie list\nprint(f\"a+b: {a+b}\")\n# można też użyć metody format\nprint(\"a+b: {}\".format(a+b))\n\n\n# mnożenie list\ntry:\n    print(a*b)\nexcept TypeError:\n    print(\"no-defined operation\")\n\nKażdy obiekt pythonowy można rozszerzyć o nowe metody i atrybuty.\n\nimport numpy as np\naa = np.array(a)\nbb = np.array(b)\n\nprint(aa,bb)\n\n\nprint(f\"aa+bb: {aa+bb}\")\n# dodawanie działa\ntry:\n    print(\"=\"*50)\n    print(aa*bb)\n    print(\"aa*bb - czy to poprawne mnożenie?\")\n    print(np.dot(aa,bb))\n    print(\"np.dot - a czy otrzymany wynik też realizuje poprawne mnożenie?\")\nexcept TypeError:\n    print(\"no-defined operation\")\n# mnożenie również działa\n\n\n# własności tablic\nx = np.array(range(4))\nprint(x)\nx.shape\n\n\nA = np.array([range(4),range(4)])\n# transposition  row i -&gt; column j, column j -&gt; row i \nA.T\n\n\n# 0-dim object\nscalar = np.array(5)\nprint(f\"scalar object dim: {scalar.ndim}\")\n# 1-dim object\nvector_1d = np.array([3, 5, 7])\nprint(f\"vector object dim: {vector_1d.ndim}\")\n# 2 rows for 3 features\nmatrix_2d = np.array([[1,2,3],[3,4,5]])\nprint(f\"matrix object dim: {matrix_2d.ndim}\")\n\n\nKurs Numpy ze strony Sebastiana Raschki",
    "crumbs": [
      "222890-D",
      "Ćwiczenia",
      "Dane ustrukturyzowane"
    ]
  },
  {
    "objectID": "lab/cw3.html#pytorch",
    "href": "lab/cw3.html#pytorch",
    "title": "Dane ustrukturyzowane",
    "section": "PyTorch",
    "text": "PyTorch\nPyTorch is an open-source Python-based deep learning library. PyTorch has been the most widely used deep learning library for research since 2019 by a wide margin. In short, for many practitioners and researchers, PyTorch offers just the right balance between usability and features.\n\nPyTorch is a tensor library that extends the concept of array-oriented programming library NumPy with the additional feature of accelerated computation on GPUs, thus providing a seamless switch between CPUs and GPUs.\nPyTorch is an automatic differentiation engine, also known as autograd, which enables the automatic computation of gradients for tensor operations, simplifying backpropagation and model optimization.\nPyTorch is a deep learning library, meaning that it offers modular, flexible, and efficient building blocks (including pre-trained models, loss functions, and optimizers) for designing and training a wide range of deep learning models, catering to both researchers and developers.\n\n\nimport torch\n\n\ntorch.cuda.is_available()\n\n\ntensor0d = torch.tensor(1) \ntensor1d = torch.tensor([1, 2, 3])\ntensor2d = torch.tensor([[1, 2, 2], [3, 4, 5]])\ntensor3d = torch.tensor([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])\n\n\nprint(tensor1d.dtype)\n\n\ntorch.tensor([1.0, 2.0, 3.0]).dtype\n\n\ntensor2d\n\n\ntensor2d.shape\n\n\nprint(tensor2d.reshape(3, 2))\n\n\nprint(tensor2d.T)\n\n\nprint(tensor2d.matmul(tensor2d.T))\n\n\nprint(tensor2d @ tensor2d.T)\n\nszczegółowe info znajdziesz w dokumentacji",
    "crumbs": [
      "222890-D",
      "Ćwiczenia",
      "Dane ustrukturyzowane"
    ]
  },
  {
    "objectID": "lab/cw3.html#modelowanie-danych-ustrukturyzowanych",
    "href": "lab/cw3.html#modelowanie-danych-ustrukturyzowanych",
    "title": "Dane ustrukturyzowane",
    "section": "Modelowanie danych ustrukturyzowanych",
    "text": "Modelowanie danych ustrukturyzowanych\nRozważmy jedną zmienną (xs) od której zależy nasza zmienna wynikowa (ys - target).\nxs = np.array([-1,0,1,2,3,4])\nys = np.array([-3,-1,1,3,5,7])\nModelem który możemy zastosować jest regresja liniowa.\n\n# Regresja liniowa \n\nimport numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nxs = np.array([-1,0,1,2,3,4])\n# a raczej \nxs = xs.reshape(-1, 1)\n\nys = np.array([-3, -1, 1, 3, 5, 7])\n\nreg = LinearRegression()\nmodel = reg.fit(xs,ys)\n\nprint(f\"solution: x1={model.coef_[0]}, x0={reg.intercept_}\")\n\nmodel.predict(np.array([[1],[5]]))\n\nProsty kod realizuje w pełni nasze zadanie znalezienia modelu regresji liniowej.\nDo czego może nam posłużyc tak wygenerowany model?\nAby z niego skorzystac potrzebujemy wyeksportować go do pliku.\n\n# save model\nimport pickle\nwith open('model.pkl', \"wb\") as picklefile:\n    pickle.dump(model, picklefile)\n\nTeraz możemy go zaimportować (np na Github) i wykorzystać w innych projektach.\n\n# load model\nwith open('model.pkl',\"rb\") as picklefile:\n    mreg = pickle.load(picklefile)\n\nAle !!! pamiętaj o odtworzeniu środowiska Pythonowego\n\nmreg.predict(xs)",
    "crumbs": [
      "222890-D",
      "Ćwiczenia",
      "Dane ustrukturyzowane"
    ]
  },
  {
    "objectID": "lab/cw3.html#siecie-neuronowe",
    "href": "lab/cw3.html#siecie-neuronowe",
    "title": "Dane ustrukturyzowane",
    "section": "siecie neuronowe",
    "text": "siecie neuronowe\n\nfrom tensorflow.keras import Sequential\nfrom tensorflow.keras.layers import Dense\n\n\nimport tensorflow as tf\n\nNa ten problem możemy popatrzeć z innej perspektywy. Sieci neuronowe również potrafią rozwiązywać problemy regresji.\n\nlayer_0 = Dense(units=1, input_shape=[1])\n\nmodel = Sequential([layer_0])\n\n# compilowanie i fitowanie\nmodel.compile(optimizer='sgd', loss='mean_squared_error')\nmodel.fit(xs, ys, epochs=10)\n\n\nprint(f\"{layer_0.get_weights()}\")",
    "crumbs": [
      "222890-D",
      "Ćwiczenia",
      "Dane ustrukturyzowane"
    ]
  },
  {
    "objectID": "lab/cw3.html#inne-sposoby-pozyskiwania-danych",
    "href": "lab/cw3.html#inne-sposoby-pozyskiwania-danych",
    "title": "Dane ustrukturyzowane",
    "section": "Inne sposoby pozyskiwania danych",
    "text": "Inne sposoby pozyskiwania danych\n\nGotowe źródła w bibliotekach pythonowych\nDane z plików zewnętrznych (np. csv, json, txt) z lokalnego dysku lub z internetu\nDane z bazy danych (np. MySQL, PostgreSQL, MongoDB)\nDane generowane w sposób sztuczny pod wybrany problem modelowy.\nStrumienie danych\n\n\nfrom sklearn.datasets import load_iris\n\niris = load_iris()\n\n\n# find all keys\niris.keys()\n\n\n# print description\nprint(iris.DESCR)\n\n\nimport pandas as pd\nimport numpy as np\n\n# create DataFrame\ndf = pd.DataFrame(data= np.c_[iris['data'], iris['target']],\n                  columns= iris['feature_names'] + ['target'])\n\n\n# show last\ndf.tail(10)\n\n\n# show info about NaN values and a type of each column.\ndf.info()\n\n\n# statistics\ndf.describe()\n\n\n# new features\ndf['species'] = pd.Categorical.from_codes(iris.target, iris.target_names)\n\n\n# remove features (columns) \ndf = df.drop(columns=['target'])\n# filtering first 100 rows and 4'th column\n\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nsns.set(style=\"whitegrid\", palette=\"husl\")\n\niris_melt = pd.melt(df, \"species\", var_name=\"measurement\")\nf, ax = plt.subplots(1, figsize=(15,9))\nsns.stripplot(x=\"measurement\", y=\"value\", hue=\"species\", data=iris_melt, jitter=True, edgecolor=\"white\", ax=ax)\n\n\nX = df.iloc[:100,[0,2]].values\ny = df.iloc[0:100,4].values\n\n\ny = np.where(y == 'setosa',-1,1)\n\n\nplt.scatter(X[:50,0],X[:50,1],color='red', marker='o',label='setosa')\nplt.scatter(X[50:100,0],X[50:100,1],color='blue', marker='x',label='versicolor')\nplt.xlabel('sepal length (cm)')\nplt.ylabel('petal length (cm)')\nplt.legend(loc='upper left')\nplt.show()\n\nDla tego typu danych separowalnych liniowo użyj modelu regresji logistycznej lub sieci neuronowej.\n\nfrom sklearn.linear_model import Perceptron\n\nper_clf = Perceptron()\nper_clf.fit(X,y)\n\ny_pred = per_clf.predict([[2, 0.5],[4,5.5]])\ny_pred",
    "crumbs": [
      "222890-D",
      "Ćwiczenia",
      "Dane ustrukturyzowane"
    ]
  },
  {
    "objectID": "lab/cw3.html#zapis-danych-i-podłączenie-do-prostej-bazy-sql",
    "href": "lab/cw3.html#zapis-danych-i-podłączenie-do-prostej-bazy-sql",
    "title": "Dane ustrukturyzowane",
    "section": "Zapis danych i podłączenie do prostej bazy SQL",
    "text": "Zapis danych i podłączenie do prostej bazy SQL\n\nIRIS_PATH = \"https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data\"\ncol_names = [\"sepal_length\", \"sepal_width\", \"petal_length\", \"petal_width\", \"class\"]\ndf = pd.read_csv(IRIS_PATH, names=col_names)\n\n\n# save to sqlite\nimport sqlite3\n# generate database\nconn = sqlite3.connect(\"iris.db\")\n# pandas to_sql\n\ntry:\n    df.to_sql(\"iris\", conn, index=False)\nexcept:\n    print(\"tabela już istnieje\")\n\n\n# sql to pandas\nresult = pd.read_sql(\"SELECT * FROM iris WHERE sepal_length &gt; 5\", conn)\n\n\nresult.head(3)\n\n\n# Dane sztucznie generowane\nfrom sklearn import datasets\nX, y = datasets.make_classification(n_samples=10**4,\nn_features=20, n_informative=2, n_redundant=2)\n\n\nfrom sklearn.ensemble import RandomForestClassifier\n\n\n# podział na zbiór treningowy i testowy\ntrain_samples = 7000 # 70% danych treningowych\n\nX_train = X[:train_samples]\nX_test = X[train_samples:]\ny_train = y[:train_samples]\ny_test = y[train_samples:]\n\nrfc = RandomForestClassifier()\nrfc.fit(X_train, y_train)\n\n\nrfc.predict(X_train[0].reshape(1, -1))",
    "crumbs": [
      "222890-D",
      "Ćwiczenia",
      "Dane ustrukturyzowane"
    ]
  },
  {
    "objectID": "lab/cw3.html#zadania",
    "href": "lab/cw3.html#zadania",
    "title": "Dane ustrukturyzowane",
    "section": "ZADANIA",
    "text": "ZADANIA\n\nZaładuj plik z danymi train.csv do pandasowej ramki danych o nazwie df\n\n\n## YOUR CODE HERE\ndf = \n\n\nWypisz liczbę wierszy i kolumn załadowanej ramki\n\n\n## YOUR CODE HERE\n\n\nDokonaj czyszczenia braków danych:\n\nopcja 1 - usuń wiersze zawierające brak danych (dropna())\nopcja 2 - usuń kolumny zawierające brak danych (drop())\nopcja 3 - dokonaj imputacji za pomocą wartości średniej (fillna())\n\n\nKtóre kolumny wybrałeś(aś) do realizacji poszczególnej opcji i dlaczego?\n\n## YOUR CODE HERE\n\n\nKorzystając z metody nunique() usuń kolumny, które nie nadają się do modelowania.\n\n\n## YOUR CODE HERE\n\n\nZamień zmienne kategoryjne z wykorzystaniem LabelEncoder na postać numeryczną\n\n\nfrom sklearn.preprocessing import LabelEncoder\nle = LabelEncoder()\n## YOUR CODE HERE\n\n\nWykorzystaj MinMaxScaler do transformacji danych zmiennoprzecinkowych do wspólnej skali\n\n\nfrom sklearn.preprocessing import MinMaxScaler\n\n## YOUR CODE HERE\n\n\nPodziel dane na zbiór treningowy (0.8) i testowy (0.2)\n\n\nfrom sklearn.model_selection import train_test_split\n## YOUR CODE HERE\nX_train, X_test, y_train, y_test = train_test_split(...., random_state=44)\n\n\nWykorzystując mapowanie możesz dla każdego pasażera przeprowadzić klasyfikację. Funkcja run() wymaga podania klasyfikatora dla pojedynczego przypadku.\n\nNapisz klasyfikator przypisujący wartość 0 lub 1 w sposób losowy (możesz wykorzystać funkcję random.randint(0,1)).\nWykonaj fukncję evaluate() i sprawdź jak dobrze radzi sobie losowy klasyfikator.\n\n\n\nclassify = ...\n\n\ndef run(f_classify, x):\n    return list(map(f_classify, x))\n\ndef evaluate(predictions, actual):\n    correct = list(filter(\n        lambda item: item[0] == item[1],\n        list(zip(predictions, actual))\n    ))\n    return f\"{len(correct)} poprawnych przewidywan z {len(actual)}. Accuracy ({len(correct)/len(actual)*100:.0f}%)\"\n\n\nevaluate(run(classify, X_train.values), y_train.values)",
    "crumbs": [
      "222890-D",
      "Ćwiczenia",
      "Dane ustrukturyzowane"
    ]
  },
  {
    "objectID": "lab/cw5.html",
    "href": "lab/cw5.html",
    "title": "przypomnienie - dane ustruktyryzowane",
    "section": "",
    "text": "from IPython.display import Image\nNa poprzednich zajęciach omawialiśmy wykorzystanie modelu regresji liniowej dla danych ustrukturyzowanych. W najprostszym przypadku dla jednej zmiennej X i jednej zmiennej celu moglibyśmy np. przypisać model w postaci:\nsatysfakcja_z_zycia = \\(\\alpha_0\\) + \\(\\alpha_1\\) PKB_per_capita\n\\(\\alpha_0\\) nazywamy punktem odcięcia (intercept) albo punktem obciążenia (bias)\nimport numpy as np\n\nnp.random.seed(42) \nm = 100\nX = 2*np.random.rand(m,1) \na_0, a_1 = 4, 3 \ny = a_0 + a_1 * X + np.random.randn(m,1)\nimport matplotlib.pyplot as plt\n\nplt.scatter(X, y)\nplt.show()\nW ogólności model liniowy: \\(\\hat{y} = \\alpha_0 + \\alpha_1 x_1 + \\alpha_2 x_2 + \\dots + \\alpha_n x_n\\) gdzie \\(\\hat{y}\\) to predykcja naszego modelu (wartość prognozowana), dla \\(n\\) cech przy wartościach cechy \\(x_i\\).\nW postaci zwektoryzowanej możemy napisać: \\(\\hat{y} = \\vec{\\alpha}^{T} \\vec{x}\\)\nW tej postaci widać dlaczego w tym modelu dokłada się kolumnę jedynek - wynikają one z wartości \\(x_0\\) dla \\(\\alpha_0\\).\n# dodajmy jedynkę do naszej tabeli \nfrom sklearn.preprocessing import add_dummy_feature\n\nX_b = add_dummy_feature(X)\nPowiedzieliśmy, że możemy w tym modelu znaleźć funkcję kosztu\n\\(MSE(\\vec{x}, \\hat{y}) = \\sum_{i=1}^{m} \\left( \\vec{\\alpha}^{T} \\vec{x}^{(i)} - y^{(i)} \\right)^{2}\\)\nTak naprawdę możemy \\(MSE(\\vec{x}, \\hat{y}) = MSE(\\vec{\\alpha})\\)\nRozwiązanie analityczne: \\(\\vec{\\alpha} = (X^{T}X)^{-1} X^T y\\)\n# rozwiązanie analityczne \nalpha_best = np.linalg.inv(X_b.T @ X_b) @ X_b.T @ y\nalpha_best, np.array([4,3])\n\n(array([[4.21509616],\n        [2.77011339]]),\n array([4, 3]))\nX_new = np.array([[0],[2]])\nX_new_b = add_dummy_feature(X_new)\ny_predict = X_new_b @ alpha_best\n\nimport matplotlib.pyplot as plt\n\nplt.plot(X_new, y_predict, \"r-\", label=\"prediction\")\nplt.plot(X,y, \"b.\")\nplt.show()\nfrom sklearn.linear_model import LinearRegression\nlin_reg = LinearRegression()\nlin_reg.fit(X,y) \n\nprint(f\"a_0={lin_reg.intercept_[0]}, a_1 = {lin_reg.coef_[0][0]}\")\n\nprint(\"predykcja\", lin_reg.predict(X_new))\n\na_0=4.215096157546746, a_1 = 2.770113386438484\npredykcja [[4.21509616]\n [9.75532293]]\n# Logistic Regression w scikit learn oparta jest o metodę lstsq \nalpha_best_svd, _, _, _ = np.linalg.lstsq(X_b, y, rcond=1e-6)\nalpha_best_svd\n\narray([[4.21509616],\n       [2.77011339]])",
    "crumbs": [
      "222890-D",
      "Ćwiczenia",
      "przypomnienie - dane ustruktyryzowane"
    ]
  },
  {
    "objectID": "lab/cw5.html#gradient-prosty",
    "href": "lab/cw5.html#gradient-prosty",
    "title": "przypomnienie - dane ustruktyryzowane",
    "section": "Gradient prosty",
    "text": "Gradient prosty\nPamiętaj o standaryzacji zmiennych (aby były one reprezentowane w tej samej skali).\n\nWsadowy gradient prosty\nW celu implementacji musimy policzyć pochodne cząstkowe dla funkcji kosztu wobec każdego parametru \\(\\alpha_i\\).\n\\(\\frac{\\partial}{\\partial \\alpha_j}MSE(\\vec{x}, \\hat{y}) = 2 \\sum_{i=1}^{m} \\left( \\vec{\\alpha}^{T} \\vec{x}^{(i)} - y^{(i)} \\right) x_j^{(i)}\\)\nKomputery posiadają własność mnożenia macierzy co pozwala obliczyć nam wszystkie pochodne w jednym obliczeniu. Wzór i algorytm liczący wszystkie pochodne “na raz” wykorzystuje cały zbiór X dlatego też nazywamy go wsadowym.\nPo obliczeniu gradientu po prostu idziemy “w przeciwną stronę”\n$ {next} = - {} MSE()$\n\nImage(filename='./img/02_10.png', width=500) \n\n\n\n\n\n\n\n\n\neta = 0.1\nn_epochs = 1000\nm = len(X_b)\nnp.random.seed(42) \nalpha = np.random.randn(2,1) # losowo wybieramy rozwiązanie\n\nfor epoch in range(n_epochs):\n    gradients = 2/m* X_b.T @ (X_b @ alpha - y)\n    #print(alpha)\n    alpha = alpha - eta*gradients\n\n\nalpha\n\narray([[4.21509616],\n       [2.77011339]])\n\n\nsprawdz jak wygladają wyniki dla różnych eta dla 0.02, 0.1, 0.5",
    "crumbs": [
      "222890-D",
      "Ćwiczenia",
      "przypomnienie - dane ustruktyryzowane"
    ]
  },
  {
    "objectID": "lab/cw5.html#stochastic-gradient-descent",
    "href": "lab/cw5.html#stochastic-gradient-descent",
    "title": "przypomnienie - dane ustruktyryzowane",
    "section": "Stochastic gradient descent",
    "text": "Stochastic gradient descent\nJednym z poważniejszych problemów wsadowego gradientu jest jego zależność od wykorzystania (w każdym kroku) całej macierzy danych. Korzystając z własności statystycznych możemy zobaczyć jak będzie realizowała się zbieżność rozwiązania jeśli za każdym razem wylosujemy próbkę danych i na niej określimy gradient. Ze względu, iż w pamięci przechowujemy tylko pewną porcję danych algorytm ten może być używany dla bardzo dużych zbiorów danych. Warto jednak mieć świadomość, że tak otrzymane wyniki mają charakter chaotyczny, co oznacza, że funkcja kosztu nie zbiega się w kierunku minimum lecz przeskakuje dążąc do minimun w sensie średniej.\n\nn_epochs = 50\nm = len(X_b)\n\n\ndef learning_schedule(t, t0=5, t1=50):\n    return t0/(t+t1)\n\nnp.random.seed(42)\nalpha = np.random.randn(2,1)\n\nfor epoch in range(n_epochs):\n    for iteration in range(m):\n        random_index = np.random.randint(m)\n        xi = X_b[random_index : random_index + 1]\n        yi = y[random_index : random_index + 1] \n        gradients = 2 * xi.T @ (xi @ alpha - yi)\n        eta = learning_schedule(epoch * m + iteration) \n        alpha = alpha - eta * gradients\n        \n\n\nalpha\n\narray([[4.21076011],\n       [2.74856079]])\n\n\n\nfrom sklearn.linear_model import SGDRegressor\n\nsgd_reg = SGDRegressor(max_iter=1000, tol=1e-5, \n                       penalty=None, eta0=0.01, \n                       n_iter_no_change=100, random_state=42)\n\nsgd_reg.fit(X, y.ravel())\n\nSGDRegressor(n_iter_no_change=100, penalty=None, random_state=42, tol=1e-05)In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.SGDRegressorSGDRegressor(n_iter_no_change=100, penalty=None, random_state=42, tol=1e-05)\n\n\n\nsgd_reg.intercept_, sgd_reg.coef_\n\n(array([4.21278812]), array([2.77270267]))",
    "crumbs": [
      "222890-D",
      "Ćwiczenia",
      "przypomnienie - dane ustruktyryzowane"
    ]
  },
  {
    "objectID": "lab/cw5.html#perceptron-i-oop",
    "href": "lab/cw5.html#perceptron-i-oop",
    "title": "przypomnienie - dane ustruktyryzowane",
    "section": "Perceptron i OOP",
    "text": "Perceptron i OOP\n\nfrom random import randint\n\nclass Kosc():\n    \"\"\"opis\"\"\"\n    def __init__(self, sciany=6):\n        \"\"\" ops metody \"\"\"\n        self.sciany = sciany\n        \n    def roll(self):\n        \"\"\"opis metody \"\"\"\n        return randint(1,self.sciany)\n\na = Kosc()\n[a.roll() for _ in range(10)]\n\n[5, 4, 3, 6, 3, 2, 2, 3, 3, 1]\n\n\n\nfrom random import choice\n\nclass RandomWalk():\n    def __init__(self, num_points=5000):\n        self.num_points = num_points\n        self.x_values = [0]\n        self.y_values = [0]\n    \n    def fill_walk(self):\n        while len(self.x_values) &lt; self.num_points:\n            x_direction = choice([-1,1])\n            x_distance = choice([0,1,2,3,4])\n            x_step = x_direction*x_distance\n            \n            y_direction = choice([-1,1])\n            y_distance = choice([0,1,2,3,4])\n            y_step = y_direction*y_distance\n            \n            if x_step == 0 and y_step == 0:\n                continue\n            \n            next_x = self.x_values[-1] + x_step\n            next_y = self.y_values[-1] + y_step\n            \n            self.x_values.append(next_x)\n            self.y_values.append(next_y)\n\nrw = RandomWalk()\nrw.x_values\nrw2 = RandomWalk(num_points=10000)\nrw2.num_points\n\nrw.fill_walk()\n\n\nimport matplotlib.pyplot as  plt\npoint_number = list(range(rw.num_points))\nplt.scatter(rw.x_values, rw.y_values, c=point_number, cmap=plt.cm.Blues,\n           edgecolor='none', s=15)\nplt.scatter(0,0,c='green', edgecolor='none', s=100)\nplt.scatter(rw.x_values[-1], rw.y_values[-1],c='red', edgecolor='none', s=100)\n\nplt.show()\n\n\n\n\n\n\n\n\n\nSztuczne neurony - rys historyczny\nW 1943 roku W. McCulloch i W. Pitts zaprezentowali pierwszą koncepcję uproszczonego modelu komórki nerwowej tzw. Nuronu McCulloch-Pittsa (MCP). W.S. McCulloch, W. Pitts, A logical Calculus of the Ideas Immanent in Nervous Activity. “The Bulletin of Mathematical Biophysics” 1943 nr 5(4)\nNeuronami nazywamy wzajemnie połączone komórki nerwowe w mózgu, które są odpowiedzialne za przetwarzanie i przesyłanie sygnałów chemicznych i elektrycznych. Komórka taka opisana jest jako bramka logiczna zawierająca binarne wyjścia. Do dendrytów dociera duża liczba sygnałów, które są integrowane w ciele komórki i (jeżeli energia przekracza określoną wartość progową) zostaje wygenerowany sygnał wyjściowy przepuszczany przez akson.\n\nImage(filename='./img/02_01.png', width=800) \n\n\n\n\n\n\n\n\nPo kilku latach Frank Rosenblatt (na podstawie MCP) zaproponował pierwszą koncepcję reguły uczenia perceprtonu. F. Rosenblatt, The Perceptron, a Perceiving and Recognizing Automaton, Cornell Aeronautical Laboratory, 1957\n\n Image(filename='./img/02_04.png', width=800) \n\n\n\n\n\n\n\n\n\nImage(filename='./img/02_02.png', width=800) \n\n\n\n\n\n\n\n\n\nimport numpy as np\nimport pandas as pd\nfrom sklearn.datasets import load_iris\n\niris = load_iris()\ndf = pd.DataFrame(data= np.c_[iris['data'], iris['target']],\n                  columns= iris['feature_names'] + ['target'])\n\n\nX = df.iloc[:100,[0,2]].values\ny = df.iloc[0:100,4].values\ny = np.where(y == 0, -1, 1)\n\nimport matplotlib.pyplot as plt\n\n\nplt.scatter(X[:50,0],X[:50,1],color='red', marker='o',label='setosa')\nplt.scatter(X[50:100,0],X[50:100,1],color='blue', marker='x',label='versicolor')\nplt.xlabel('sepal length (cm)')\nplt.ylabel('petal length (cm)')\nplt.legend(loc='upper left')\nplt.show()\n\n\n\n\n\n\n\n\ndziecko = Perceptron()\ndziecko.fit()\n\n# dziecko musi mieć parametr uczenia\ndziecko.eta\n\n# możemy sprawdzić jak szybko się uczy == ile błędów robi\n\ndziecko.errors_ \n\n# rozwiązania znajdą się w wagach\ndziecko.w_\n# w naszym przypadku dziecko uczy się dwóch wag !\n\n\nclass Perceptron():\n    def __init__(self, n_iter=10, eta=0.01):\n        self.n_iter = n_iter\n        self.eta = eta\n        \n    def fit(self, X, y):\n        self.w_ = np.zeros(1+X.shape[1])\n        self.errors_ = []\n        for _ in range(self.n_iter):\n            pass\n        return self\n\n\nimport random\n\nclass Perceptron():\n    \n    def __init__(self, eta=0.01, n_iter=10):\n        self.eta = eta\n        self.n_iter = n_iter\n    \n    def fit(self, X, y):\n        \n        #self.w_ = np.zeros(1+X.shape[1])\n        self.w_ = [random.uniform(-1.0, 1.0) for _ in range(1+X.shape[1])] \n        self.errors_ = []\n        \n        for _ in range(self.n_iter):\n            errors = 0\n            for xi, target in zip(X,y):\n                #print(xi, target)\n                update = self.eta*(target-self.predict(xi))\n                #print(update)\n                self.w_[1:] += update*xi\n                self.w_[0] += update\n                #print(self.w_)\n                errors += int(update != 0.0)\n            self.errors_.append(errors)\n        return self\n    \n    def net_input(self, X):\n        return np.dot(X, self.w_[1:])+self.w_[0]\n    \n    def predict(self, X):\n        return np.where(self.net_input(X)&gt;=0.0, 1, -1)\n\n\n# uzycie jak wszsytkie klasy sklearn\nppn = Perceptron()\nppn.fit(X,y)\n\n&lt;__main__.Perceptron at 0xffff584a6e50&gt;\n\n\n\nprint(ppn.errors_)\nprint(ppn.w_)\n\n[7, 5, 5, 5, 4, 2, 3, 2, 3, 1]\n[-0.004915667492470639, -0.08431647234956788, 0.17845900873492573]\n\n\n\nppn.predict(np.array([-3, 5]))\n\narray(1)\n\n\n\n# dodatkowa funkcja\n\nfrom matplotlib.colors import ListedColormap\n\ndef plot_decision_regions(X,y,classifier, resolution=0.02):\n    markers = ('s','x','o','^','v')\n    colors = ('red','blue','lightgreen','gray','cyan')\n    cmap = ListedColormap(colors[:len(np.unique(y))])\n\n    x1_min, x1_max = X[:,0].min() - 1, X[:,0].max()+1\n    x2_min, x2_max = X[:,1].min() -1, X[:,1].max()+1\n    xx1, xx2 = np.meshgrid(np.arange(x1_min, x1_max, resolution),\n                           np.arange(x2_min, x2_max, resolution))\n    Z = classifier.predict(np.array([xx1.ravel(), xx2.ravel()]).T)\n    Z = Z.reshape(xx1.shape)\n    plt.contourf(xx1, xx2, Z, alpha=0.4, cmap=cmap)\n    plt.xlim(xx1.min(), xx1.max())\n    plt.ylim(xx2.min(),xx2.max())\n\n    for idx, cl in enumerate(np.unique(y)):\n        plt.scatter(x=X[y == cl,0], y=X[y==cl,1], alpha=0.8, c=cmap(idx), marker=markers[idx], label=cl)\n\n# dla kwiatków\n\n\nplot_decision_regions(X,y,classifier=ppn)\nplt.xlabel(\"dlugosc dzialki [cm]\")\nplt.ylabel(\"dlugosc platka [cm]\")\nplt.legend(loc='upper left')\nplt.show()\n\n/tmp/ipykernel_47975/2939353802.py:21: UserWarning: *c* argument looks like a single numeric RGB or RGBA sequence, which should be avoided as value-mapping will have precedence in case its length matches with *x* & *y*.  Please use the *color* keyword-argument or provide a 2D array with a single row if you intend to specify the same RGB or RGBA value for all points.\n  plt.scatter(x=X[y == cl,0], y=X[y==cl,1], alpha=0.8, c=cmap(idx), marker=markers[idx], label=cl)\n\n\n\n\n\n\n\n\n\n\nImage(filename='./img/02_09.png', width=600) \n\n\n\n\n\n\n\n\n\n# ZADANIE - Opisz czym różni się poniższy algorytm od Perceprtona ? \nclass Adaline():\n    '''Klasyfikator  - ADAptacyjny LIniowy NEuron'''\n    def __init__(self, eta=0.01, n_iter=10):\n        self.eta = eta\n        self.n_iter = n_iter\n\n    def fit(self, X,y):\n        #self.w_ = np.zeros(1+X.shape[1])\n        import random\n        self.w_ = [random.uniform(-1.0, 1.0) for _ in range(1+X.shape[1])]\n        self.cost_ = []\n\n        for i in range(self.n_iter):\n            net_input = self.net_input(X)\n            output = self.activation(X)\n            errors = (y-output)\n            self.w_[1:] += self.eta * X.T.dot(errors)\n            self.w_[0] += self.eta * errors.sum()\n            cost = (errors**2).sum() / 2.0\n            self.cost_.append(cost)\n        return self\n\n    def net_input(self, X):\n        return np.dot(X, self.w_[1:]) + self.w_[0]\n\n    def activation(self, X):\n        return self.net_input(X)\n\n    def predict(self, X):\n        return np.where(self.activation(X) &gt;= 0.0, 1, -1) \n\n\nad = Adaline(n_iter=20, eta=0.01)\n\nad.fit(X,y)\n\nprint(ad.w_)\n\nplot_decision_regions(X,y,classifier=ad)\nplt.xlabel(\"dlugosc dzialki [cm]\")\nplt.ylabel(\"dlugosc platka [cm]\")\nplt.legend(loc='upper left')\nplt.show()\n\n[-7.455249717834115e+29, -4.1637224208297825e+30, -2.329539601257149e+30]\n\n\n/tmp/ipykernel_47975/2939353802.py:21: UserWarning: *c* argument looks like a single numeric RGB or RGBA sequence, which should be avoided as value-mapping will have precedence in case its length matches with *x* & *y*.  Please use the *color* keyword-argument or provide a 2D array with a single row if you intend to specify the same RGB or RGBA value for all points.\n  plt.scatter(x=X[y == cl,0], y=X[y==cl,1], alpha=0.8, c=cmap(idx), marker=markers[idx], label=cl)\n\n\n\n\n\n\n\n\n\n\nad.cost_[:10]\n\n[140.08713411457336,\n 10130.555141038189,\n 15796202.248846438,\n 24639830805.940037,\n 38434640654686.06,\n 5.995258709511885e+16,\n 9.351753101299814e+19,\n 1.4587408201236906e+23,\n 2.275428742873221e+26,\n 3.5493460472673884e+29]\n\n\n\nad2 = Adaline(n_iter=100, eta=0.0001)\n\nad2.fit(X,y)\n\nplot_decision_regions(X,y,classifier=ad2)\nplt.xlabel(\"dlugosc dzialki [cm]\")\nplt.ylabel(\"dlugosc platka [cm]\")\nplt.legend(loc='upper left')\nplt.show()\n\n/tmp/ipykernel_47975/2939353802.py:21: UserWarning: *c* argument looks like a single numeric RGB or RGBA sequence, which should be avoided as value-mapping will have precedence in case its length matches with *x* & *y*.  Please use the *color* keyword-argument or provide a 2D array with a single row if you intend to specify the same RGB or RGBA value for all points.\n  plt.scatter(x=X[y == cl,0], y=X[y==cl,1], alpha=0.8, c=cmap(idx), marker=markers[idx], label=cl)\n\n\n\n\n\n\n\n\n\n\nprint(ad2.w_)\n\nad2.cost_[-10:]\n\n[-0.8997065712259897, 0.009396352215446133, 0.3262108547290658]\n\n\n[18.84904336445426,\n 18.48924749328044,\n 18.137348502663738,\n 17.793173068484943,\n 17.456551670817138,\n 17.12731851042961,\n 16.805311427124423,\n 16.490371819865356,\n 16.182344568659914,\n 15.881077958155881]\n\n\n\n%%file app.py\n\nimport pickle\nfrom math import log10\n\nfrom flask import Flask\nfrom flask import request\nfrom flask import jsonify\nimport numpy as np\n\nclass Perceptron():\n    \n    def __init__(self, eta=0.01, n_iter=10):\n        self.eta = eta\n        self.n_iter = n_iter\n    \n    def fit(self, X, y):\n        self.w_ = [random.uniform(-1.0, 1.0) for _ in range(1+X.shape[1])] \n        self.errors_ = []\n        \n        for _ in range(self.n_iter):\n            errors = 0\n            for xi, target in zip(X,y):\n                update = self.eta*(target-self.predict(xi))\n                self.w_[1:] += update*xi\n                self.w_[0] += update\n                errors += int(update != 0.0)\n            self.errors_.append(errors)\n        return self\n    \n    def net_input(self, X):\n        return np.dot(X, self.w_[1:])+self.w_[0]\n    \n    def predict(self, X):\n        return np.where(self.net_input(X)&gt;=0.0, 1, -1)\n\n# Create a flask\napp = Flask(__name__)\n\n# Create an API end point\n@app.route('/api/v1.0/predict', methods=['GET'])\ndef get_prediction():\n\n    # sepal length\n    sepal_length = float(request.args.get('sl'))\n    petal_length = float(request.args.get('pl'))\n    \n    features = [sepal_length, petal_length]\n\n    # Load pickled model file\n    with open('model.pkl',\"rb\") as picklefile:\n        model = pickle.load(picklefile)\n        \n    # Predict the class using the model\n    predicted_class = int(model.predict(features))\n    \n    # Return a json object containing the features and prediction\n    return jsonify(features=features, predicted_class=predicted_class)\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000)\n\n\nimport requests\nresponse = requests.get(\"http://127.0.0.1:5000/api/v1.0/predict?sl=6.3&pl=2.6\")\nprint(response.content)",
    "crumbs": [
      "222890-D",
      "Ćwiczenia",
      "przypomnienie - dane ustruktyryzowane"
    ]
  },
  {
    "objectID": "wyklad4.html",
    "href": "wyklad4.html",
    "title": "Analiza danych w czasie rzeczywistym",
    "section": "",
    "text": "Architektura przesyłania strumieniowego to określony zestaw technologii, które współpracują ze sobą w celu obsługi przetwarzania strumieniowego, co jest praktyką podejmowania działań na serii danych w momencie ich tworzenia. W wielu nowoczesnych wdrożeniach Apache Kafka działa jako magazyn danych przesyłanych strumieniowo, a następnie wiele procesorów strumieniowych może działać na danych przechowywanych w Kafce w celu wygenerowania wielu danych wyjściowych. Niektóre architektury przesyłania strumieniowego obejmują przepływy pracy zarówno do przetwarzania strumieniowego, jak i przetwarzania wsadowego, które obejmują inne technologie do obsługi przetwarzania wsadowego na dużą skalę lub wykorzystują Kafkę jako magazyn centralny, jak określono w architekturze Kappa.\nDoskonała architektura przetwarzania danych w czasie rzeczywistym musi być odporna na błędy i skalowalna; musi obsługiwać aktualizacje wsadowe i przyrostowe oraz być rozszerzalna.\nNa początku badamy dwie podstawowe architektury przetwarzania danych, Lambda i Kappa, które stanowią podstawę różnych aplikacji korporacyjnych.\n\n\nArchitektura Lambda obejmuje warstwę wsadową (batch layer), warstwę strumieniowa (stream layer) i warstwę serwowania.\nWarstwa wsadowa działa na pełnych danych, dzięki czemu system może generować najdokładniejsze wyniki. Jednak wyniki są okupione dużymi opóźnieniami wynikającymi z długiego czasu obliczeń. Warstwa wsadowa przechowuje surowe dane w miarę ich nadejścia i oblicza widoki wsadowe do wykorzystania. Naturalnie procesy wsadowe będą występować w pewnych odstępach czasu i będą długotrwałe. Zakres danych wynosi od godzin do kilku lat.\nWarstwa strumieniowa:\n\ngeneruje wyniki z małymi opóźnieniami i w czasie zbliżonym do rzeczywistego.\noblicza widoki w czasie rzeczywistym w celu uzupełnienia widoków wsadowych.\nodbiera napływające dane i aktualizuje wyniki warstwy wsadowej. Koszt obliczeń jest znacznie obniżony dzięki algorytmom przyrostowym zaimplementowanym w warstwie szybkości.\n\nWidoki wsadowe mogą być przetwarzane przy użyciu bardziej złożonych lub kosztownych reguł i mogą mieć lepszą jakość danych i mniej przekrzywień, podczas gdy widoki w czasie rzeczywistym zapewniają bieżący dostęp do najnowszych możliwych danych.\nWreszcie warstwa serwująca umożliwia różne zapytania o wyniki przesłane z warstw wsadowych i szybkich. Dane wyjściowe z warstwy wsadowej w postaci widoków wsadowych i warstwy szybkości w postaci opinii w czasie zbliżonym do rzeczywistego są przekazywane do warstwy obsługującej, która wykorzystuje te dane do obsługi oczekujących zapytań na zasadzie ad-hoc.\n  Implementacja:  \nDobre bo:\n\nDobra równowaga między szybkością, niezawodnością i skalowalnością.\nDostęp do wyników zarówno w czasie rzeczywistym, jak i offline, bardzo dobrze pokrywa wiele scenariuszy analizy danych.\nDostęp do pełnego zestawu danych w oknie wsadowym może przynieść określone optymalizacje, które sprawią, że Lambda będzie wydajniejsza i jeszcze prostsza do wdrożenia.\n\nKiepskie gdy:\n\nWewnętrzna logika przetwarzania jest taka sama (warstwy wsadowe i warstwy czasu rzeczywistego) - wiele zduplikowanych modułów i kodowania.\nZbiór danych modelowany za pomocą architektury Lambda jest trudny do migracji i reorganizacji.\n\n\n\n\nArchitektura Kappa to architektura oprogramowania używana do przetwarzania danych przesyłanych strumieniowo. Głównym założeniem Architektury Kappa jest możliwość wykonywania przetwarzania w czasie rzeczywistym i przetwarzania wsadowego, zwłaszcza w celach analitycznych, za pomocą jednego stosu technologicznego. Opiera się na architekturze przesyłania strumieniowego, w której przychodzące serie danych są najpierw przechowywane w silniku przesyłania wiadomości, takim jak Apache Kafka. Stamtąd silnik przetwarzania strumienia odczyta dane, przekształci je w format nadający się do analizy, a następnie zapisze je w analitycznej bazie danych, aby użytkownicy końcowi mogli wyszukiwać.\nArchitektura Kappa obsługuje analizy (prawie) w czasie rzeczywistym, gdy dane są odczytywane i przekształcane natychmiast po umieszczeniu ich w silniku przesyłania komunikatów. Dzięki temu najnowsze dane są szybko dostępne dla zapytań użytkowników końcowych. Obsługuje również analizę historyczną, odczytując zapisane dane przesyłane strumieniowo z mechanizmu przesyłania wiadomości później w sposób wsadowy, aby utworzyć dodatkowe możliwe do analizy dane wyjściowe dla większej liczby typów analiz.\nArchitektura Kappa jest prostszą alternatywą dla architektury Lambda, ponieważ wykorzystuje ten sam stos technologii do obsługi strumienia w czasie rzeczywistym i historycznego przetwarzania wsadowego. Obie architektury obejmują przechowywanie danych historycznych w celu umożliwienia analiz na dużą skalę. Obie architektury są również pomocne w rozwiązywaniu problemów związanych z „tolerancją błędów ludzkich”, w których problemy z kodem przetwarzania (błędy lub znane ograniczenia) można przezwyciężyć, aktualizując kod i ponownie uruchamiając go na danych historycznych. Główna różnica w stosunku do architektury Kappa polega na tym, że wszystkie dane są traktowane jako strumień, więc silnik przetwarzania strumienia działa jako jedyny silnik transformacji danych.\n \nImplementation Example:  \n\n\n\n\nAplikacje mogą odczytywać i zapisywać bezpośrednio do Kafki zgodnie z rozwojem. W przypadku istniejących źródeł zdarzeń detektory są teraz przyzwyczajone do przesyłania strumieniowego raportów z dzienników bazy danych, co eliminuje konieczność przetwarzania wsadowego podczas ruchu przychodzącego, co skutkuje mniejszą liczbą zasobów.\nZapytania muszą uwzględniać tylko jedną lokalizację serwowania, zamiast sprawdzać widoki partii i szybkości.\n\n\n\n\n\nniełatwe do wdrożenia, zwłaszcza w przypadku odtwarzania danych.\n\n\n\n\nObie architektury obsługują analizy w czasie rzeczywistym i historyczne w jednym środowisku. Jednak istotną zaletą architektury Kappa w porównaniu z architekturą Lambda jest to, że umożliwia ona zbudowanie systemu przesyłania strumieniowego i przetwarzania wsadowego na jednej technologii. Oznacza to, że możesz zbudować aplikację przetwarzającą strumienie do obsługi danych w czasie rzeczywistym, a jeśli musisz zmodyfikować dane wyjściowe, zaktualizuj swój kod, a następnie ponownie uruchom go na danych w mechanizmie przesyłania komunikatów w sposób wsadowy. Jak sugeruje architektura Lambda, nie ma osobnej technologii do obsługi przetwarzania wsadowego.\nPrzy wystarczająco szybkim silniku przetwarzania strumieniowego możesz nie potrzebować innej technologii zoptymalizowanej pod kątem przetwarzania wsadowego. Odczytujesz równolegle przechowywane dane przesyłane strumieniowo (zakładając, że dane w Kafce są odpowiednio podzielone na osobne kanały lub „partycje”) i przekształcasz dane tak, jakby pochodziły ze źródła strumieniowego. W przypadku niektórych środowisk możliwe do przeanalizowania dane wyjściowe można utworzyć na żądanie. Gdy nowe zapytanie zostanie przesłane przez użytkownika końcowego, dane mogą zostać przekształcone ad hoc, aby uzyskać optymalną odpowiedź na to zapytanie. Ponownie wymaga to szybkiego silnika przetwarzania strumieniowego, aby zapewnić małe opóźnienia.\nChociaż architektura Lambda nie określa technologii, których należy użyć, komponent przetwarzania wsadowego jest często wykonywany na platformie big data z wykorzystaniem Apache Hadoop. Rozproszony system plików Hadoop (HDFS) umożliwia ekonomiczne przechowywanie „surowych danych”, które można przekształcić za pomocą narzędzi Hadoop w format umożliwiający analizę. Podczas gdy Hadoop jest używany w komponencie systemu do przetwarzania wsadowego, oddzielny silnik przeznaczony do przetwarzania strumieniowego jest używany w komponencie analitycznym w czasie rzeczywistym. Jednak jedną z zalet architektury Lambda jest to, że znacznie większe zestawy danych (w zakresie petabajtów) można przechowywać i przetwarzać wydajniej w Hadoop w celu analizy historycznej na dużą skalę.",
    "crumbs": [
      "222890-D",
      "Wykłady",
      "Architektury strumieniowania danych"
    ]
  },
  {
    "objectID": "wyklad4.html#architektury-strumieniowania-danych",
    "href": "wyklad4.html#architektury-strumieniowania-danych",
    "title": "Analiza danych w czasie rzeczywistym",
    "section": "",
    "text": "Architektura przesyłania strumieniowego to określony zestaw technologii, które współpracują ze sobą w celu obsługi przetwarzania strumieniowego, co jest praktyką podejmowania działań na serii danych w momencie ich tworzenia. W wielu nowoczesnych wdrożeniach Apache Kafka działa jako magazyn danych przesyłanych strumieniowo, a następnie wiele procesorów strumieniowych może działać na danych przechowywanych w Kafce w celu wygenerowania wielu danych wyjściowych. Niektóre architektury przesyłania strumieniowego obejmują przepływy pracy zarówno do przetwarzania strumieniowego, jak i przetwarzania wsadowego, które obejmują inne technologie do obsługi przetwarzania wsadowego na dużą skalę lub wykorzystują Kafkę jako magazyn centralny, jak określono w architekturze Kappa.\nDoskonała architektura przetwarzania danych w czasie rzeczywistym musi być odporna na błędy i skalowalna; musi obsługiwać aktualizacje wsadowe i przyrostowe oraz być rozszerzalna.\nNa początku badamy dwie podstawowe architektury przetwarzania danych, Lambda i Kappa, które stanowią podstawę różnych aplikacji korporacyjnych.\n\n\nArchitektura Lambda obejmuje warstwę wsadową (batch layer), warstwę strumieniowa (stream layer) i warstwę serwowania.\nWarstwa wsadowa działa na pełnych danych, dzięki czemu system może generować najdokładniejsze wyniki. Jednak wyniki są okupione dużymi opóźnieniami wynikającymi z długiego czasu obliczeń. Warstwa wsadowa przechowuje surowe dane w miarę ich nadejścia i oblicza widoki wsadowe do wykorzystania. Naturalnie procesy wsadowe będą występować w pewnych odstępach czasu i będą długotrwałe. Zakres danych wynosi od godzin do kilku lat.\nWarstwa strumieniowa:\n\ngeneruje wyniki z małymi opóźnieniami i w czasie zbliżonym do rzeczywistego.\noblicza widoki w czasie rzeczywistym w celu uzupełnienia widoków wsadowych.\nodbiera napływające dane i aktualizuje wyniki warstwy wsadowej. Koszt obliczeń jest znacznie obniżony dzięki algorytmom przyrostowym zaimplementowanym w warstwie szybkości.\n\nWidoki wsadowe mogą być przetwarzane przy użyciu bardziej złożonych lub kosztownych reguł i mogą mieć lepszą jakość danych i mniej przekrzywień, podczas gdy widoki w czasie rzeczywistym zapewniają bieżący dostęp do najnowszych możliwych danych.\nWreszcie warstwa serwująca umożliwia różne zapytania o wyniki przesłane z warstw wsadowych i szybkich. Dane wyjściowe z warstwy wsadowej w postaci widoków wsadowych i warstwy szybkości w postaci opinii w czasie zbliżonym do rzeczywistego są przekazywane do warstwy obsługującej, która wykorzystuje te dane do obsługi oczekujących zapytań na zasadzie ad-hoc.\n  Implementacja:  \nDobre bo:\n\nDobra równowaga między szybkością, niezawodnością i skalowalnością.\nDostęp do wyników zarówno w czasie rzeczywistym, jak i offline, bardzo dobrze pokrywa wiele scenariuszy analizy danych.\nDostęp do pełnego zestawu danych w oknie wsadowym może przynieść określone optymalizacje, które sprawią, że Lambda będzie wydajniejsza i jeszcze prostsza do wdrożenia.\n\nKiepskie gdy:\n\nWewnętrzna logika przetwarzania jest taka sama (warstwy wsadowe i warstwy czasu rzeczywistego) - wiele zduplikowanych modułów i kodowania.\nZbiór danych modelowany za pomocą architektury Lambda jest trudny do migracji i reorganizacji.\n\n\n\n\nArchitektura Kappa to architektura oprogramowania używana do przetwarzania danych przesyłanych strumieniowo. Głównym założeniem Architektury Kappa jest możliwość wykonywania przetwarzania w czasie rzeczywistym i przetwarzania wsadowego, zwłaszcza w celach analitycznych, za pomocą jednego stosu technologicznego. Opiera się na architekturze przesyłania strumieniowego, w której przychodzące serie danych są najpierw przechowywane w silniku przesyłania wiadomości, takim jak Apache Kafka. Stamtąd silnik przetwarzania strumienia odczyta dane, przekształci je w format nadający się do analizy, a następnie zapisze je w analitycznej bazie danych, aby użytkownicy końcowi mogli wyszukiwać.\nArchitektura Kappa obsługuje analizy (prawie) w czasie rzeczywistym, gdy dane są odczytywane i przekształcane natychmiast po umieszczeniu ich w silniku przesyłania komunikatów. Dzięki temu najnowsze dane są szybko dostępne dla zapytań użytkowników końcowych. Obsługuje również analizę historyczną, odczytując zapisane dane przesyłane strumieniowo z mechanizmu przesyłania wiadomości później w sposób wsadowy, aby utworzyć dodatkowe możliwe do analizy dane wyjściowe dla większej liczby typów analiz.\nArchitektura Kappa jest prostszą alternatywą dla architektury Lambda, ponieważ wykorzystuje ten sam stos technologii do obsługi strumienia w czasie rzeczywistym i historycznego przetwarzania wsadowego. Obie architektury obejmują przechowywanie danych historycznych w celu umożliwienia analiz na dużą skalę. Obie architektury są również pomocne w rozwiązywaniu problemów związanych z „tolerancją błędów ludzkich”, w których problemy z kodem przetwarzania (błędy lub znane ograniczenia) można przezwyciężyć, aktualizując kod i ponownie uruchamiając go na danych historycznych. Główna różnica w stosunku do architektury Kappa polega na tym, że wszystkie dane są traktowane jako strumień, więc silnik przetwarzania strumienia działa jako jedyny silnik transformacji danych.\n \nImplementation Example:  \n\n\n\n\nAplikacje mogą odczytywać i zapisywać bezpośrednio do Kafki zgodnie z rozwojem. W przypadku istniejących źródeł zdarzeń detektory są teraz przyzwyczajone do przesyłania strumieniowego raportów z dzienników bazy danych, co eliminuje konieczność przetwarzania wsadowego podczas ruchu przychodzącego, co skutkuje mniejszą liczbą zasobów.\nZapytania muszą uwzględniać tylko jedną lokalizację serwowania, zamiast sprawdzać widoki partii i szybkości.\n\n\n\n\n\nniełatwe do wdrożenia, zwłaszcza w przypadku odtwarzania danych.\n\n\n\n\nObie architektury obsługują analizy w czasie rzeczywistym i historyczne w jednym środowisku. Jednak istotną zaletą architektury Kappa w porównaniu z architekturą Lambda jest to, że umożliwia ona zbudowanie systemu przesyłania strumieniowego i przetwarzania wsadowego na jednej technologii. Oznacza to, że możesz zbudować aplikację przetwarzającą strumienie do obsługi danych w czasie rzeczywistym, a jeśli musisz zmodyfikować dane wyjściowe, zaktualizuj swój kod, a następnie ponownie uruchom go na danych w mechanizmie przesyłania komunikatów w sposób wsadowy. Jak sugeruje architektura Lambda, nie ma osobnej technologii do obsługi przetwarzania wsadowego.\nPrzy wystarczająco szybkim silniku przetwarzania strumieniowego możesz nie potrzebować innej technologii zoptymalizowanej pod kątem przetwarzania wsadowego. Odczytujesz równolegle przechowywane dane przesyłane strumieniowo (zakładając, że dane w Kafce są odpowiednio podzielone na osobne kanały lub „partycje”) i przekształcasz dane tak, jakby pochodziły ze źródła strumieniowego. W przypadku niektórych środowisk możliwe do przeanalizowania dane wyjściowe można utworzyć na żądanie. Gdy nowe zapytanie zostanie przesłane przez użytkownika końcowego, dane mogą zostać przekształcone ad hoc, aby uzyskać optymalną odpowiedź na to zapytanie. Ponownie wymaga to szybkiego silnika przetwarzania strumieniowego, aby zapewnić małe opóźnienia.\nChociaż architektura Lambda nie określa technologii, których należy użyć, komponent przetwarzania wsadowego jest często wykonywany na platformie big data z wykorzystaniem Apache Hadoop. Rozproszony system plików Hadoop (HDFS) umożliwia ekonomiczne przechowywanie „surowych danych”, które można przekształcić za pomocą narzędzi Hadoop w format umożliwiający analizę. Podczas gdy Hadoop jest używany w komponencie systemu do przetwarzania wsadowego, oddzielny silnik przeznaczony do przetwarzania strumieniowego jest używany w komponencie analitycznym w czasie rzeczywistym. Jednak jedną z zalet architektury Lambda jest to, że znacznie większe zestawy danych (w zakresie petabajtów) można przechowywać i przetwarzać wydajniej w Hadoop w celu analizy historycznej na dużą skalę.",
    "crumbs": [
      "222890-D",
      "Wykłady",
      "Architektury strumieniowania danych"
    ]
  },
  {
    "objectID": "wyklad4.html#publikujsubskrybuj",
    "href": "wyklad4.html#publikujsubskrybuj",
    "title": "Analiza danych w czasie rzeczywistym",
    "section": "Publikuj/Subskrybuj",
    "text": "Publikuj/Subskrybuj\nSystem przesyłania wiadomości „Publikuj/Subskrybuj” ma kluczowe znaczenie dla aplikacji opartych na danych. Komunikaty Pub/Sub to wzorzec charakteryzujący się tym, że nadawca (publikujący) fragmentu danych (wiadomości) nie kieruje go wprost do odbiorcy. pub/sub to systemy, które często posiadają brokera czyli centralny punkt, w którym znajdują się wiadomości.",
    "crumbs": [
      "222890-D",
      "Wykłady",
      "Architektury strumieniowania danych"
    ]
  },
  {
    "objectID": "wyklad4.html#apache-kafka",
    "href": "wyklad4.html#apache-kafka",
    "title": "Analiza danych w czasie rzeczywistym",
    "section": "Apache Kafka",
    "text": "Apache Kafka\nNa witrynie Kafki znajdziesz definicję:\n\nRozproszona platforma streamingowa\n\nCo to jest „platforma rozproszonego przesyłania strumieniowego”?\nNajpierw chcę przypomnieć, czym jest „strumień”. Strumienie to po prostu nieograniczone dane, dane, które nigdy się nie kończą. Ciągle ich przybywa i możesz przetwarzać je w czasie rzeczywistym.\nA „rozproszone”? Rozproszony oznacza, że ​​Kafka działa w klastrze, a każdy węzeł w grupie nazywa się Brokerem. Ci brokerzy to po prostu serwery wykonujące kopię Apache Kafka.\nTak więc Kafka to zestaw współpracujących ze sobą maszyn, aby móc obsługiwać i przetwarzać nieograniczone dane w czasie rzeczywistym.\nJego rozproszona architektura jest jednym z powodów, dla których Kafka stał się tak sławny. Brokerzy sprawiają, że jest odporny, niezawodny, skalowalny i odporny na błędy. Ale dlaczego panuje błędne przekonanie, że Kafka to kolejny „kolejkowy system przesyłania wiadomości”?\nAby odpowiedzieć na tę odpowiedź, musimy najpierw wyjaśnić, jak działa kolejkowe przesyłanie wiadomości.\n\nKolejkowy system przesyłania wiadomości\nPrzesyłanie wiadomości, to po prostu czynność wysyłania wiadomości z jednego miejsca do drugiego. Ma trzech głównych “aktorów”:\n\nProducent: Który tworzy i wysyła komunikaty do jednej lub więcej kolejek;\nKolejka: struktura danych bufora, która odbiera (od producentów) i dostarcza komunikaty (do konsumentów) w sposób FIFO (First-In-First-Out). Po otrzymaniu powiadomienia jest ono na zawsze usuwane z kolejki; nie ma szans na odzyskanie go;\nKonsument: subskrybuje jedną lub więcej kolejek i otrzymuje ich wiadomości po opublikowaniu.\n\nI to jest to; tak działa przesyłanie wiadomości. Jak widać, nie ma tu nic o strumieniach, czasie rzeczywistym czy klastrach.\n\n\nArchitektura Kafki\nDużo informacji znajdziesz pod tym linkiem.\nTeraz, gdy wiemy, jak działa przesyłanie wiadomości, zanurzmy się w świat Kafki. W Kafce mamy też „Producentów” i „Konsumentów”; działają w bardzo podobny sposób, jak w kolejkowych systemach, produkując i konsumując komunikaty.\n \nJak widać, jest to bardzo podobne do tego, o czym rozmawialiśmy o przesyłaniu wiadomości, ale tutaj nie mamy pojęcia „kolejki”. Zamiast tego mamy „Tematy” (Topic).\n„Temat” to szczególny typ strumienia danych; jest bardzo podobny do kolejki, odbiera i dostarcza wiadomości, ale jest kilka pojęć, które musimy zrozumieć w odniesieniu do tematów:\n\nTemat jest podzielony na partycje; każdy temat może mieć jedną lub więcej partycji i musimy określić tę liczbę podczas tworzenia topicu. Możesz sobie wyobrazić topic jako folder w systemie operacyjnym, a każdy folder wewnątrz niego jako partycję.\nKażda wiadomość zostanie zapisana na dysku brokera i otrzyma offset (unikalny identyfikator). Offset jest unikalny na poziomie partycji; każda partycja ma swój własny zbiór offsetów. To jeszcze jeden powód, który sprawia, że ​​Kafka jest tak wyjątkowa, przechowuje wiadomości na dysku (jak baza danych, a w rzeczywistości Kafka też jest bazą danych), aby w razie potrzeby odzyskać je później. W odróżnieniu od systemu przesyłania wiadomości, gdzie wiadomość jest usuwana po zużyciu;\nKosumenci używają offsetu do czytania wiadomości, od najstarszej do najnowszej. W przypadku awarii konsumenta zacznie odczytywać końcowe wartości realizowane po nawiązaniu połączenia.\n\n \n\n\nBrokerzy\nJak wspomniano wcześniej, Kafka działa w sposób rozproszony. W razie potrzeby klaster Kafka może zawierać wielu brokerów.\n \nKażdy broker w klastrze jest identyfikowany przez identyfikator i zawiera co najmniej jedną partycję tematyczną. Aby skonfigurować liczbę partycji w każdym brokerze, podczas tworzenia tematu musimy skonfigurować coś, co nazywa się współczynnikiem replikacji. Powiedzmy, że mamy trzech brokerów w naszym klastrze, temat z trzema partycjami i współczynnikiem replikacji równym trzy; w takim przypadku każdy broker będzie odpowiedzialny za jedną sekcję emisji.\nJak widać na powyższym obrazku, \\(Topic_1\\) ma trzy partycje; każdy broker jest odpowiedzialny za sekcję tematu, więc współczynnik replikacji \\(Topic_1\\) wynosi trzy. Liczba partycji musi być zgodna z liczbą brokerów; w ten sposób każdy broker będzie odpowiedzialny za jedną sekcję tematu.\n\n\nProducenci\nPodobnie jak w świecie kolejkowych systemów, „Producenci” w Kafce to ci, którzy tworzą i wysyłają wiadomości do tematów. Jak wspomniano wcześniej, wiadomości są wysyłane w sposób okrężny. Przykład: wiadomość 01 trafia do partycji 0 tematu 1, a wiadomość 02 do partycji 1 tego samego tematu. Oznacza to, że nie możemy zagwarantować, że wiadomości stworzone przez tego samego producenta zawsze będą dostarczane w tym samym numerze. Podczas wysyłania wiadomości musimy określić klucz; Kafka wygeneruje skrót na podstawie tego klucza i będzie wiedział, która partycja ma dostarczyć tę wiadomość. Ten skrót uwzględnia liczbę partycji tematu; dlatego tego numeru nie można zmienić, gdy temat jest już utworzony.\n\n\nKonsumenci i grupy konsumentów\nKonsumenci to aplikacje zasubskrybowane do jednego lub więcej tematów, które będą odczytywać wiadomości stamtąd. Mogą czytać z jednej lub więcej partycji. Gdy konsument odczytuje tylko z jednej partycji, możemy zapewnić kolejność odczytu, ale gdy pojedynczy konsument odczytuje z dwóch lub więcej partycji, będzie czytać równolegle, więc nie ma gwarancji kolejności odczytu. Na przykład wiadomość, która przyszła później, może zostać odczytana przed inną, która przyszła wcześniej. Dlatego musimy być ostrożni przy wyborze liczby partycji i podczas tworzenia wiadomości.\nInnym ważnym pojęciem Kafki są „Grupy konsumentów”. Jest to bardzo ważne, gdy musimy skalować odczytywanie wiadomości. Staje się to bardzo kosztowne, gdy pojedynczy konsument musi czytać z wielu partycji, więc musimy zrównoważyć obciążenie między naszymi konsumentami, wtedy wchodzą grupy konsumentów.\nDane z jednego tematu będą równoważone obciążeniem między konsumentami, dzięki czemu możemy zagwarantować, że nasi konsumenci będą w stanie obsługiwać i przetwarzać dane. Ideałem jest posiadanie takiej samej liczby konsumentów w grupie, jaką mamy jako partycje w temacie, w ten sposób każdy konsument czyta tylko z jednego. Podczas dodawania konsumentów do grupy należy uważać, jeśli liczba konsumentów jest większa niż liczba partycji, niektórzy konsumenci nie będą czytać z żadnego tematu i pozostaną bezczynni.",
    "crumbs": [
      "222890-D",
      "Wykłady",
      "Architektury strumieniowania danych"
    ]
  },
  {
    "objectID": "indexS.html",
    "href": "indexS.html",
    "title": "Informacje ogólne",
    "section": "",
    "text": "Kod: 222890-S\nSemestr letni 2024, SGH Szkoła Główna Handlowa w Warszawie\nSzczegółowy opis znajdziesz w sylabusie. Znajdziesz w nim opis wszystkich wykładów i ćwiczeń oraz proponowaną literaturę.\nInne książki zamieszczone zostały w zakładce książki"
  },
  {
    "objectID": "indexS.html#analiza-danych-w-czasie-rzeczywistym",
    "href": "indexS.html#analiza-danych-w-czasie-rzeczywistym",
    "title": "Informacje ogólne",
    "section": "",
    "text": "Kod: 222890-S\nSemestr letni 2024, SGH Szkoła Główna Handlowa w Warszawie\nSzczegółowy opis znajdziesz w sylabusie. Znajdziesz w nim opis wszystkich wykładów i ćwiczeń oraz proponowaną literaturę.\nInne książki zamieszczone zostały w zakładce książki"
  },
  {
    "objectID": "indexS.html#kalendarz",
    "href": "indexS.html#kalendarz",
    "title": "Informacje ogólne",
    "section": "Kalendarz",
    "text": "Kalendarz\n\nWykład\n\n\n02-03-2024 (sobota) 08:00-09:30 - Wykład 1 - G Aula VI\n\nTematy reazlizowane na wykładzie:\n\nDane ustrukturyzowane i nieustrukturyzowane\nProcesy generowania danych\nBig Data\nModele przetwarzania danych OLTP, OLAP\nBiznesowe wymagania dla strumieni danych\n\n\n16-03-2024 (sobota) 08:00-09:30 - Wykład 2 - G Aula VI\n\nTematy:\n\nDefinicje: Zdarzenie, strumień zdarzeń, analiza i przetwarzanie strumieni zdarzeń,\nNarzędzie i aplikacje przetwarzania strumieniowego\nAPI klient-serwer, Pub-Sub i Apache Kafka\n\n\n\n\nlaboratorium\n\n\n06-04-2024 (sobota) 08:00-15:00 - G116 4 grupy\n\n\n07-04-2024 (niedziela) 09:50-17.00 - G116 4 grupy\n\n\n\nWprowadzenie do środowiska Python\nFlask API\n\n\n\n20-04-2024 (sobota) 08:00-15:00 - G116 4 grupy\n\n\n21-04-2024 (niedziela) 09:50-17.00 - G116 4 grupy\n\n\n\ndane ustrukturyzowane\ndane nieustrukturyzowane\nobiektowe podejście do modelowania danych\npodłączenie do bazy relacyjnej (sqlite)\npodłączenie do bazy nierelacyjnej (mongodb)\n\n\n04-05-2024 (sobota) 08:00-15:00 - G116 4 grupy\n05-05-2024 (niedziela) 09:50-17.00 - G116 4 grupy\n25-05-2024 (sobota) 08:00-15:00 - G116 4 grupy\n26-05-2024 (niedziela) 09:50-17.00 - G116 4 grupy\n08-06-2022 (sobota) 08:00-15:00 - G116 4 grupy\n09-06-2022 (niedziela) 09:50-17.00 - G116 4 grupy\n\n\nMiejsce\nWykłady 1-2: G-Aula VI Laboratorium 1-5: 116 G\n\n\nZaliczenie i Egzamin\nWykłady zakończone zostaną testem (ostatnie zajęcia). Pozytywna ocena z testu (powyżej 13 pkt) upoważnia do realizacji ćwiczeń.\nPo ćwiczeniach realizowane będą zadania domowe przekazywane za pośrednictwem platformy teams.\nZaliczenie wszystkich ćwiczeń i zadań upoważnia do realizacji projektu.\nProjekt powinien być realizowany w grupach max 5 osobowych.\nWymagania projektu:\n\nProjekt powinien przedstawiać BIZNESOWY PROBLEM, który można realizować wykorzystując informacje podawane w trybie online. (Nie oznacza to, że nie można korzystać z procesowania batchowego np w celu wygenerowania modelu).\nDane powinny być przesyłane do Apache Kafki i stamtąd poddawane dalszemu procesowaniu i analizie.\nJęzyk programowania jest dowolny - dotyczy każdego komponentu projektu.\nMożna wykorzystać narzędzia BI\nŹródłem danych może być tabela, sztucznie generowane dane, IoT itp."
  },
  {
    "objectID": "indexS.html#technologie",
    "href": "indexS.html#technologie",
    "title": "Informacje ogólne",
    "section": "Technologie",
    "text": "Technologie\nUczestnicząc w zajęciach musisz opanować i przynajmniej w podstawowym zakresie posługiwać się następującymi technologiami informatycznymi:\n\nGIT\nPython, Jupyter notebook, Jupyter lab, Colab\nDocker\nApache Spark, Apache Flink, Apache Kafka, Apache Beam\nDatabricks Community edition Web page."
  }
]